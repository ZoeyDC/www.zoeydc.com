[{"content":"當桌⾯應⽤程式需要網路資源時，可以⽤ HttpClient 或 WebClient 等發送 HTTP 請求，但有時反過來想要開放桌⾯程式的資源供外界使⽤呢？這時就可以⽤ Self Host 的⽅式，不需要依附 IIS 就可以在程式裡掛載 Web API，為程式和外界聯繫提供⼀個管道。\n本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。\n一、系統環境  Windows 10 Visual Studio 2019 .NET Framework 4.7.2  ⼆、建立 Startup.cs，Web API 的進入點 ⾸先，安裝套件：\n Install-Package Microsoft.AspNet.WebApi.OwinSelfHost -Version 5.2.7\n （OWIN 為 .NET Framework 4.5 以上使⽤， 4.0 ⽤ Microsoft.AspNet.WebApi.SelfHost 裝載 Web API）\n接著新增類別（或 OWIN 啟動類別）Startup.cs，設定路由規則，讓 Web API 以此規則在 OWIN 上運⾏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  using System.Web.Http; //using System.Web.Http.Cors; using Microsoft.Owin; using Owin; [assembly: OwinStartup(typeof(SelfHostConsole.Startup))] namespace SelfHostConsole { public class Startup { public void Configuration(IAppBuilder app) { // 如需如何設定應用程式的詳細資訊，請瀏覽 https://go.microsoft.com/fwlink/?LinkID=316888  // Configure Web API for self-host.  HttpConfiguration config = new HttpConfiguration(); config.Routes.MapHttpRoute( name: \u0026#34;DefaultApi\u0026#34;, routeTemplate: \u0026#34;api/{controller}/{id}\u0026#34;, defaults: new { id = RouteParameter.Optional } );  //Enable CORS  //config.EnableCors(new EnableCorsAttribute(\u0026#34;*\u0026#34;, headers: \u0026#34;*\u0026#34;, methods: \u0026#34;*\u0026#34;));  app.UseWebApi(config);  } } }   如果網站需要跨域資源共享（CORS），則需安裝 CORS 套件，並啟用上述第 2 和 22 ⾏：\n Install-Package Microsoft.AspNet.WebApi.Cors -Version 5.2.7\n 接下來在 Program.cs 裡設定執⾏程式時啟動 Web API host：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using Microsoft.Owin.Hosting; using System; namespace SelfHostConsole { class Program { static void Main(string[] args) { string baseAddress = \u0026#34;http://localhost:55000/\u0026#34;; Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(url: baseAddress)) { Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); }  } } }   此時若以 Postman 測試 Get 訪問 http://localhost:55000/ 會收到 404 Not Found，⽽不是出現 Error: connect ECONNREFUSED 127.0.0.1:55000 這樣的訊息，表⽰這時候 Web API 的基本架構已經完成了。\n三、加入 Controller 依照習慣取代配置（Convention over Configuration）的原則，Controller 以 Controller 結尾就可以被找到，這邊簡單加個 TestController。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System.Collections.Generic; using System.Web.Http; namespace SelfHostConsole { public class TestController : ApiController { private static List\u0026lt;MyModel\u0026gt; list = new List\u0026lt;MyModel\u0026gt;() { new MyModel(){Name=\u0026#34;name1\u0026#34;, Value=\u0026#34;value1\u0026#34;}, new MyModel(){Name=\u0026#34;name2\u0026#34;, Value=\u0026#34;value2\u0026#34;}, }; // GET api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Get() { return list; } // GET api/test/1  public MyModel Get(int id) { if (id \u0026lt; 0 || id \u0026gt;= list.Count) return null; return list[id]; } // POST api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Post([FromBody] MyModel newData) { list.Add(newData); return list; } } public class MyModel { public string Name { get; set; } public string Value { get; set; } } }   這樣 Web API 就可以運作了。\n⽤ Postman 測試⼀下，運作正常。\n 如果 Postman 收到以下的訊息，確認⼀下是否有將 Controller 設為 public class。\n1 2 3 4  { \u0026#34;Message\u0026#34;: \u0026#34;No HTTP resource was found that matches the request URI \u0026#39;http://localhost:55000/api/test\u0026#39;.\u0026#34;, \u0026#34;MessageDetail\u0026#34;: \u0026#34;No type was found that matches the controller named \u0026#39;test\u0026#39;.\u0026#34; }   四、安裝 SSL 憑證，啟⽤ HTTPS 若要啟⽤ HTTPS，程式碼網址部分直接修改成 https 即可。除此之外環境要安裝 SSL 憑證。\n1. 建立 SSL 憑證 這邊⽤ OpenSSL 建立憑證，取得 crt 和 pfx 檔後，匯入⾃簽憑證到「受信任的根憑證授權單位」和「伺服器憑證」。\n以系統管理員⾝分執⾏命令提⽰字元，其中 CertPassword 取代為在建立 pfx 檔時所輸入的密碼。：\n1  certutil -f -p CertPassword -importpfx \u0026#34;server.pfx\u0026#34;   2. 取得憑證指紋（Thumbprint） 在「開始」功能表搜尋 mmc 或 certlm.msc ，進到憑證管理介⾯，在「個⼈」或「受信任的根憑證授權單位」中找到匯入的憑證名稱，快點兩下進到「詳細資料」畫⾯，將憑證指紋記錄下來。（也可⽤ openssl 取得憑證指紋)\n 3. 將 SSL 憑證和 Port 綁定 以系統管理員⾝分執⾏命令提⽰字元，其中 certhash 為上⼀步驟得到的憑證指紋，appid 則填入任意⼀組 GUID。：\n1  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a}   4. 進⾏測試 Postman 測試時可能會出現 Error: self signed certificate，是因為憑證檢核時⾃簽憑證無法過關，需要在設定裡將「SSL certificate verification」關閉（建議測試完後恢復進⾏檢核）。正常來說可以得到和先前⼀樣的結果，除了網址 http 現在換成 https。\n五、繫結多個 IP 或域名 在 Program.cs 啟動 Web API 是使用 WebApp.Start(url: baseAddress) 來設定網址，觀察它的 Metadata，Start 方法除了傳入 url 網址外，還有另一個傳入 StartOptions 的多載，裡面有個 Urls 的 Property，說明為「A list of url prefixes to listen on. Overrides port.」，所以就是從這邊下手了。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Program { static void Main(string[] args) { StartOptions options = new StartOptions(); options.Urls.Add(\u0026#34;https://localhost:55000/\u0026#34;); options.Urls.Add(\u0026#34;http://localhost:55001/\u0026#34;);  Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(options: options)) \t{ Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); } } }   這樣就完成了多個 IP 的繫結。\n補充 1. SSL 憑證安裝刪除查詢 參考「⽤ certutil 新增刪除查詢 SSL 憑證」。\n2. SSL 繫結 Port 及刪除、查詢繫結 1 2 3 4  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a} netsh http delete sslcert ipport=0.0.0.0:55000 netsh http show sslcert netsh http show sslcert ipport=0.0.0.0:55000   3. 在 Windows Service 中啟動 Web API 覆寫 OnStart 與 OnStop 方法時分別建立和釋放 Web API 資源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using Microsoft.Owin.Hosting; using System; using System.ServiceProcess; namespace SelfHost { public partial class SelfHostService : ServiceBase { private IDisposable _server = null;  public SelfHostService() { InitializeComponent(); } protected override void OnStart(string[] args) { _server = WebApp.Start\u0026lt;Startup\u0026gt;(\u0026#34;https://localhost:55000/\u0026#34;);  } protected override void OnStop() { if (_server != null) { _server.Dispose(); }  base.OnStop(); } } }   相關連結：  [Microsoft Docs] ⾃我裝載 ASP.NET Web API 1 （C#） [Microsoft Docs] 使⽤ OWIN ⾃我裝載 ASP.NET Web API [Microsoft Docs] 如何：使⽤ MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] 作法：使⽤ SSL 憑證設定連接埠 [WILL保哥] 如何使⽤ OpenSSL 建立開發測試⽤途的⾃簽憑證 (Self-Signed Certificate) [⿊暗執⾏緒] PostMan 無法連線 IIS Express 網站 OWIN WebAPI Service example ","description":"本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。","id":0,"section":"posts","tags":["OWIN","Self Host","ASP.NET","Web API","SSL","IIS"],"title":"免 IIS，⽤ OWIN 架設輕量級 ASP.NET Web API","uri":"https://www.zoeydc.com/zh/posts/2021-06-13-owin-selfhost-webapi-console/"},{"content":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。\n前置作業：查詢憑證指紋（Fingerprint、Thumbprint） 本篇憑證是⽤ OpenSSL 所產⽣的 crt 和 pfx 檔，另外刪除或查詢憑證資訊時需⽤到憑證指紋，可 (1) 直接⽤ OpenSSL 取得，或 (2) 匯入憑證後進到 MMC 介⾯查詢 。\n(1) OpenSSL 將取得類似「SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB」的⼀串文字，使⽤時取「Fingerprint=」之後的文字並將冒號去除。\n以命令提示字元執行查詢：\n1 2 3 4 5 6 7 8 9  REM CertificateFile 為憑證檔名稱 REM 查詢憑證指紋 \u0026gt; openssl x509 -in CertificateFile.crt -fingerprint -noout SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB REM 查詢序號 \u0026gt; openssl x509 -in CertificateFile.crt -serial -noout serial=6D53BD345F83AF5C3CFC1CE36C2540273C74B607   (2) MMC 介面  受信任的根憑證授權單位（root） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  REM 匯入 certutil -addstore -f \u0026#34;ROOT\u0026#34; CertificateFile.crt REM 上述匯入憑證後，如要再匯入密鑰（⼀般不需要） REM CertPassword 為產⽣ pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx root \u0026#34;CertificateFile.pfx\u0026#34; REM 依憑證指紋進行刪除 certutil -delstore root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有受信任的根憑證 certutil -store root REM 針對憑證指紋進⾏查詢 certutil -store root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   個⼈存放區（my） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  REM 匯入憑證（無密鑰） certutil -addstore -f my CertificateFile.crt REM 匯入憑證及密鑰到個人存放區，「同時」也會新增到受信任的根憑證授權單位 root REM CertPassword 為產生 pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx my \u0026#34;CertificateFile.pfx\u0026#34; (certutil -f -p CertPassword -importpfx \u0026#34;CertificateFile.pfx\u0026#34;) REM 依憑證指紋進行刪除 REM 只刪除在個人存放區 \u0026#34;my\u0026#34; 的憑證，刪除在 \u0026#34;root\u0026#34; 的憑證需要另外執行 certutil -delstore my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有個人憑證 certutil -store my REM 針對憑證指紋進行查詢 certutil -store my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   備註1：若匯入 pfx 檔到個人存放區，則在 IIS 的伺服器憑證中也可以查詢到。\n備註2：若是從 IIS 伺服器憑證匯入憑證到個人存放區，那就只會在個人存放區有，不會同時新增到 root。\n備註3：若是管理「目前的使用者」（Current User）的憑證，在 certutil 後加上 -user 即可，例如：certutil -user -addstore -f my CertificateFile.crt。「目前的使用者」的憑證會繼承「本機電腦」所有的憑證，除了在「本機電腦」的「個人存放區」的憑證（參考連結3）。\n相關連結：  [Microsoft Docs] 如何：使用 MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] certutil [Microsoft Docs] Local Machine and Current User Certificate Stores ","description":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。","id":1,"section":"posts","tags":["certutil","SSL"],"title":"⽤ certutil 新增刪除查詢 SSL 憑證","uri":"https://www.zoeydc.com/zh/posts/2021-06-04-certutil-store-ssl/"},{"content":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定（例如資料庫連線字串、系統資源對應路徑等），這些繁瑣的設定若是每次都⼿動修改實在容易出錯，⽽ Visual Studio 本⾝就有 Web.config 組態檔轉換功能，好好利⽤可以⼤⼤節約時間並降低錯誤機率，更能專注在開發本⾝。\n專案建立好時預設有兩個組態 Debug 和 Release，⼀般我會再建立⼀個 Test 組態在測試環境使⽤，所以本篇記錄 1. 如何新增組態和與之對應的 Web.config 設定檔，和 2. 設定 Web.config 轉換內容。\n⼀、前置作業  以 ASP.NET MVC 的預設範本建立專案（Visual Studio 2019） 檢視預設組態設定：預設的 Debug 和 Release 組態各有⼀個對應的 config 檔（Web.{組態名稱}.config）   ⼆、新增組態設定與設定檔 從「組態管理員」中新增「Test」組態後，在⽅案總管中會發現 Web.Test.config 檔案並沒有⾃動產⽣，需要⼿動「新增設定轉換」（Add Transform），檔案就會出現了。\n  三、設定不同組態發⾏時對應的 Web.config 接下來要編輯這些檔案裡⾯的內容了！了解語法之前來快速看⼀下⼀個簡單的轉換範例和呈現的效果。\n範例與效果 就以發佈 Release 組態來說，假設原本的 Web.config 有個參數 Env：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Dev\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 對照在 Web.Release.config 的 Env 參數設定，除了將 value 設為 Release 外，另外加了 xdt:Transform 和 xdt:Locator 屬性（屬性詳細說明⾒下方語法詳述），如下：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Release\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(key)\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 實際發佈時， Env 的設定就會轉換為 Release了。\n或者可以⽤內建的預覽⼯具發佈前預先檢視結果與差異處：\n  ↑ 左邊是原始的設定檔，右邊則是轉換後的結果，差異處也都⾃動標記了。\n語法詳述（Web.config Transformation Syntax） 回顧⼀下 Web.Release.config 的原始內容，或者新建的 Web.Test.config 也有相同的內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!-- 如需使用 web.config 轉換的詳細資訊，請前往 https://go.microsoft.com/fwlink/?LinkId=125889 --\u0026gt; \u0026lt;configuration xmlns:xdt=\u0026#34;http://schemas.microsoft.com/XML-Document-Transform\u0026#34;\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;SetAttributes\u0026#34; 轉換只會在 \u0026#34;Match\u0026#34; 定位程式找到 值為 \u0026#34;MyDB\u0026#34; 的屬性 \u0026#34;name\u0026#34; 時，才將 \u0026#34;connectionString\u0026#34; 的值變 更為使用 \u0026#34;ReleaseSQLServer\u0026#34;。 \u0026lt;connectionStrings\u0026gt; \u0026lt;add name=\u0026#34;MyDB\u0026#34; connectionString=\u0026#34;Data Source=ReleaseSQLServer;Initial Catalog=MyReleaseDB;Integrated Security=True\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(name)\u0026#34;/\u0026gt; \u0026lt;/connectionStrings\u0026gt; --\u0026gt; \u0026lt;system.web\u0026gt; \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;Replace\u0026#34; 轉換將會取代 web.config 檔案 的整個 \u0026lt;customErrors\u0026gt; 區段。 請注意，因為在 \u0026lt;system.web\u0026gt; 節點之下 只有一個 customErrors 區段，所以不需要使用 \u0026#34;xdt:Locator\u0026#34; 屬性。 \u0026lt;customErrors defaultRedirect=\u0026#34;GenericError.htm\u0026#34; mode=\u0026#34;RemoteOnly\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34;\u0026gt; \u0026lt;error statusCode=\u0026#34;500\u0026#34; redirect=\u0026#34;InternalError.htm\u0026#34;/\u0026gt; \u0026lt;/customErrors\u0026gt; --\u0026gt; \u0026lt;/system.web\u0026gt; \u0026lt;/configuration\u0026gt;   和⼀般 Web.config 不同的是，它引⽤了 XML-Document-Transform 命名空間（第 3 ⾏），對應到 xdt 前置詞的使⽤（xdt:Locator 和 xdt:Transform），⽤來處理元素和屬性的轉換；xdt 前置詞在轉換後的文件中不會出現。\n【Locator】 ⽤來定位要轉換的元素位置，為非必要屬性，若未設定時則找出所有同層級元素，再依 Transform 屬性決定轉換模式。Locator 有三種設定⽅式。\nxdt:Locator=\u0026#34;Condition(XPath 運算式)\u0026#34; 範例：xdt:Locator=\u0026#34;Condition(@name=\u0026#39;oldname\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;)\u0026#34; 說明：找到符合 XPath 運算式條件的元素。例如屬性 name 為 oldname 或 providerName 為 oldprovider 的所有元素。\nxdt:Locator=\u0026#34;Match(屬性1,屬性2,屬性3,…)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;Match(name, providerName)\u0026#34; 說明：找到與所列屬性的值「皆」相同的元素。例如屬性 name 為 AWLT 且 providerName 為 newprovider 的所有元素。\nxdt:Locator=\u0026#34;XPath(XPath 運算式)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT2\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;XPath(/configuration/connectionStrings/add[@name=\u0026#39;AWLT\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;])\u0026#34;/\u0026gt; 說明：完全使⽤ XPath 運算式（絕對路徑）來尋找元素，不以元素現在的位置為參考。例如即使將上述標籤放到 \u0026lt;appSettings\u0026gt; 元素下或直接放在 \u0026lt;configuration\u0026gt; 底下，其依然會找到 connectionStrings 中，符合 name 為 AWLT 或 providerName 為 oldprovider 的所有元素。\n【Transform】 說明元素屬性該如何轉換，有八種⽅式。\nxdt:Transform=\u0026#34;Replace\u0026#34; 說明：以轉換檔（Web.{組態名稱}.config）中的元素取代 Locator 屬性在 Web.config 中會找到的元素。如果找到多個元素，只會取代第⼀個。\nxdt:Transform=\u0026#34;Insert\u0026#34; 說明：將轉換檔的元素加入 Web.config 中 Locator 所定義的同層級的元素區域中的最後⾯。\nxdt:Transform=\u0026#34;InsertBefore(XPath 運算式)\u0026#34; 說明：將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素前⾯（不是 Locator 所指的元素，在此處 Locator 沒有作⽤）。\n1 2 3  \u0026lt;authorization\u0026gt; \u0026lt;allow roles=\u0026#34;Admins\u0026#34; xdt:Transform= \u0026#34;InsertBefore(/configuration/system.web/authorization/deny[@users=\u0026#39;*\u0026#39;])\u0026#34; /\u0026gt; \u0026lt;/authorization\u0026gt;   上⾯範例設定轉換時在「拒絕所有使⽤者」的項⽬前，插入「允許系統管理者」的授權。\nxdt:Transform=\u0026#34;InsertAfter(XPath 運算式)\u0026#34; 說明：和 InsertBefort 相反，是將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素後⾯。\nxdt:Transform=\u0026#34;Remove\u0026#34; 說明：移除 Locator 找到的第⼀個元素。\nxdt:Transform=\u0026#34;RemoveAll\u0026#34; 說明：移除 Locator 找到的所有元素。\nxdt:Transform=\u0026#34;RemoveAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，移除所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆移除。\n1  \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;   Web.Release.config 預設就會移除 compilation 的 debug 屬性，以提⾼發⾏時程式運⾏的效能。（原始內容第 16 ⾏）\nTransform=\u0026#34;SetAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，依照轉換檔的屬性設定所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆依轉換檔進⾏設定。\n參考網址：  [Microsoft Docs] 使用 Visual Studio 的 ASP.NET Web 部署： Web.config 檔轉換 [Microsoft Docs] Web.config Transformation Syntax for Web Application Project Deployment ","description":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定，若能善用 Visual Studio 本⾝組態檔的轉換功能，可以⼤⼤節約時間並降低錯誤機率，更能專注在開發上。本篇記錄 (1) 如何新增組態和 Web.config 設定檔，和 (2) 設定 Web.config 轉換內容。","id":2,"section":"posts","tags":["visual studio","config transforms"],"title":"Visual Studio 發佈專案時⾃動轉換組態對應的 Web.config","uri":"https://www.zoeydc.com/zh/posts/2021-05-29-visual-studio-webconfig/"},{"content":"一直有建部落格的想法，也試過一些部落格平台和 WordPress，覺得平台上開站雖然方便，只要註冊帳號就好，但是版型調整方式有限，無法將網站改成符合自己心意的模樣，相較而言，WordPress 自由度很高，不過架構也相對複雜，還需要管理外掛和資料庫，有點麻煩，不太符合單純寫文章的想法，經過一番搜尋後，決定用靜態網站來架設我的部落格！\n雖然 GitHub Pages 推薦使用 Jekyll 生成靜態網頁，但在 Windows 環境下 Jekyll 似乎比較不友善，而 Hugo 入門相對容易、官方文件有完整的教學，還有編譯速度快等優點，眾多因素考慮下，我選擇了 Hugo。\n不過還是花了一些時間才把網站搞定，所以決定要記錄一下整個架站過程，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域，以供參考。\n 以下 {username} 為 GitHub 帳號名，{主題名稱} 為所選的佈景主題名稱，例如我的是 zzo。\n 本機端開發環境的建置 本機環境  作業系統：Windows 10\n Hugo 可以安裝在 Windows、Linux、macOS 等作業系統，Linux 或 macOS 的安裝方式請參考官方文件。\n以下建置過程預設環境已安裝 Git，也註冊 GitHub 帳號並建立名稱為 {username}.github.io 的 repo 了。\n安裝套件管理器 CHOCOLATEY 以系統管理員身分執行 PowerShell，執行以下指令：\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))   若安裝無誤，執行 choco 可得版本資訊，例如：\n1 2 3  \u0026gt; choco Chocolatey v0.10.15 Please run \u0026#39;choco -?\u0026#39; or \u0026#39;choco \u0026lt;command\u0026gt; -?\u0026#39; for help menu.   安裝 Hugo、建立新網站 PowerShell 繼續執行：\n1  choco install hugo -confirm   如果選擇的主題需要擴充套件 Sass/SCSS 版本，執行：\n1  choco install hugo-extended -confirm   若不確定是否需要擴充套件的話，可以先跳過，之後執行 hugo server 出現以下類似錯誤時再安裝 hugo-extended：\n ERROR 2021/05/08 16:44:51 TOCSS: failed to transform \u0026ldquo;main_parsed.scss\u0026rdquo; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS.\n 安裝完 Hugo 後，就可以建立新網站了。\n1 2  cd myfolder ## Hugo 會在此資料夾底下新建一個資料夾 hugo new site mywebsite ## 建立網站 \u0026amp; 資料夾 mywebsite   這個資料夾底下會建立 archetypes、content、static、themes 等資料夾，但 themes 裡面沒有預設的佈景主題，需要自己安裝。\n可以到所選的主題的 GitHub repo 下載檔案解壓縮到 themes/{主題名稱}/ 或是用 git submodule 安裝（以下以 zzo 主題為例）。\n1 2 3  cd mywebsite ## 進入網站資料夾 git init git submodule add https://github.com/zzossig/hugo-theme-zzo themes/zzo   安裝完成後，官方文件使用指令新增組態檔 config.toml：\n1  echo theme = \\\u0026#34;zzo\\\u0026#34; \u0026gt;\u0026gt; config.toml   但建議直接複製範例網站，到 themes/{主題名稱}/exampleSite/ 目錄下複製整個資料夾內容貼到 mywebsite 根目錄，再來修改組態檔，尤其有些佈景主題的組態檔結構複雜，只新增 config.toml 可能會缺少某些參數而編譯失敗。\n如果要自訂 layouts 或 i18n 的內容，也從 themes/{主題名稱}/ 下複製資料夾到根目錄後進行修改。\n先來設定 config.toml 的 baseURL 和網站語言等：\n1 2 3 4 5 6 7  # 如果使用 GitHub Pages 預設域名 baseURL = \u0026#34;https://{username}.github.io/\u0026#34; # 自訂域名範例 baseURL = \u0026#34;https://www.customdomainname.com/\u0026#34; languageCode = \u0026#34;zh-tw\u0026#34; title = \u0026#34;My Site Name\u0026#34; #自訂任意名稱   本機端啟動網站：\n以 hugo servre 方式啟動網站，Hugo 會隨時偵測檔案的異動來更新網頁，到預設網址 http://localhost:1313/ 就可以看到最新的內容，關閉網站用 CTRL+C 。\n1  hugo server   上傳到 Github Pages 發布網站 官方文件使用 GitHub Action 來佈署網站（方法一），但如果不希望將網站的原始碼放到網路上，可以選擇只提交最後編譯好的靜態網頁（方法二）。\n方法一：建立 gh-pages 分支 先確定使用的 Hugo 版本，以及是否安裝擴充套件。\n1 2  \u0026gt; hugo version hugo v0.83.1-5AFE0A57+extended windows/amd64 BuildDate=2021-05-02T14:38:05Z VendorInfo=gohugoio   將整個資料夾 Push 到 Github repo （{username}.github.io）：\n1 2 3 4 5 6  ## 現在路徑為 myfolder/mywebsite/ git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git remote add origin https://github.com/{username}/{username}.github.io.git git push -u origin main   再到 GitHub 新增 gh-pages.yml 檔案。\n  在上圖步驟 2 時，將 gh-pages.yml 內容用以下內容取代，其中 hugo-version 和 extended 再依需求進行設定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  name:github pageson:push:branches:- main # Set a branch to deployjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;# \u0026#39;0.83.1\u0026#39;# extended: true # 有用擴充套件則將 # 移除- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public  Commit 完成後，檢查 workflow 是否順利。（之後每次 main 分支有 commit 就會有新的 workflow 自動產生，重新編譯發布網站）\n  全部都 ✔ 表示順利完成編譯囉。\n接下來設定 GitHub Pages 要讀取 gh-pages 分支的檔案，設定完就可以到 https://{username}.github.io 瀏覽網站成果。\n 方法二：上傳 Public 資料夾 先以 hugo 產生靜態 html 檔案，成功的話會在 mywebsite/public/ 裡面看到檔案，再將 public 資料夾 push 到 GitHub。\n1 2 3 4 5 6 7 8 9  ## 現在路徑為 myfolder/mywebsite/ git submodule add https://github.com/{username}/{username}.github.io.git public hugo # 產生靜態 html 檔案 cd public git status # 檢查 public 資料夾，應只看到 public 中新增的檔案 git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git push -u origin main   參考上圖到 GitHub Pages 設定要讀取的分支為 main，就可以訪問 https://{username}.github.io。\n自訂網域 GitHub 官方建議先在 GitHub 中設定 CNAME，再到 DNS 供應商設定 DNS 紀錄。\n新增檔案 CNAME 在 GitHub 網站介面中可以設定網域名，其機制是在 Pages 的目標分支根目錄下加上 CNAME，但是這樣每次有檔案更新 CNAME 就會被覆蓋掉，要再重新設定，所以 Hugo 網站是要新增 CNAME 在 static 資料夾中，這樣編譯後，檔案會自動放在網站根目錄下，GitHub 就能以此偵測自訂域名。\nCNAME 檔案（無副檔名）內容就只放自訂的網域名（例如 www.customdomainname.com）。\n設定 DNS 到 DNS 供應商設定 DNS 紀錄，增加 4 筆 A Record 和 1 筆 CNAME Record（以 www 為例）。\n   Type Host Value     A Record @ 185.199.108.153   A Record @ 185.199.109.153   A Record @ 185.199.110.153   A Record @ 185.199.111.153   CNAME Record www {username}.github.io    更改 repo 名稱（非必要） 最後可以將 repo 名稱改為現在的網域，然後將 Pages 的 Enforce HTTPS 取消再重新勾選，讓 SSL 憑證重新產生。\n結論 基本上一步一步執行就可以完成 Hugo 網站建置，如果一開始就打算自訂網域也可以先新增 CNAME 檔案以及用自訂網域作 repo 名稱來簡化步驟！\n參考網址：  Hugo Docs GitHub Docs 自訂網域  其他：  編寫 Markdown 文件 ","description":"使用 Hugo 在 GitHub Pages 架設靜態網站，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域。","id":3,"section":"posts","tags":["Hugo","Static Site Generator","Git","GitHub Pages"],"title":"網站開張！在 GitHub Pages 架設 Hugo 靜態網站","uri":"https://www.zoeydc.com/zh/posts/2021-05-23-hugo-website_github-pages_custom-domain/"}]