[{"content":"因為過去基礎沒打好😆，最近在用 struct 時一直有些疑慮，決定還是將這部分好好弄清楚，所以就整理了這篇筆記，記錄 .NET「通用語言運行庫」（CLR；Common Language Runtime）如何管理和配置記憶體資源，來存取程式運行中用到的實值型別（value types）或參考型別（reference types）變數資料。\n.NET 和 CLR 簡單而言，CLR 就是讓 .NET 應用程式可以運作的虛擬機器。\n不同 .NET 語言的來源程式碼，被各自的編譯器編譯後，都會編譯成 CIL（通用中間語言）程式碼，儲存在二進制檔案（.exe/.dll）中。當二進制檔案被執行時，CLR 才會將 CIL 即時編譯成適用於該系統環境的機器程式碼；同時 CLR 也管理和作業系統溝通與安全性問題等諸多事項，而記憶體管理就是其中一項。\n 因為 .NET 程式需要依靠 CLR 來運行，是受 CLR 所管控，所以也將這些稱為受控程式碼（managed code）；但如果是 C/C++ 程式，所有和系統環境的溝通都是由程式碼自己處理，故稱為非受控程式碼（unmanaged code）。\n記憶體管理 .NET 程式執行時，CLR 會保留一塊連續的記憶體空間供程式使用（不受其他程式干擾），這個記憶體空間將劃分為三個區塊：Static、Stack 和 Heap。\nStatic（靜態）- High Frequency Heap   存放靜態成員、靜態方法。 程式執行期間一直佔用記憶體空間，不會釋出。   程式載入後，每一次遇到遇到新的靜態成員或方法（或者所屬類別的 instance 第一次建立前），就會配置 Static 區塊的記憶體給那個靜態成員或方法使用。這在程式執行期間只會配置這麼一次，之後就一直占用同樣的記憶體位址，直到程式結束才會釋出，所以靜態成員或方法多時，會占用比較多的記憶體空間。\n實作上，.NET 將 Static 區塊放在 High Frequency Heap。\nStack（堆疊）   存放區域變數，如果變數為實值型別，其值也存放在 Stack 中，如果變數為參考型別，其指標（Pointer；Heap 記憶體位址）存放在 Stack 中。 變數宣告後開始占用記憶體，離開變數可見範圍完成生命週期後，記憶體空間自動回收。   Stack 是以「後進先出」的陣列結構來存取資料。隨著程式執行緒方向前進，每宣告一個區域變數時，這個變數就會在 Stack 中「堆疊」，而在離開函式變數不再使用後，記憶體空間會自動釋放。所以先宣告的變數的記憶體空間會最後釋放，最後宣告的變數會最先回收（Last In, First Out；LIFO）。儲存在 Stack 的資料其生命週期是可以預測的，不須特意管理記憶體的釋放。\n但因為記憶體空間是有限的，程式沒有寫好而造成無限迴圈或無限遞迴時，Stack 空間不足會發生溢位錯誤（StackOverflowException）。\nHeap（堆積）- GC Heap   存放參考型別變數的值（物件本身）和封箱的（Boxed）實值型別變數等。 當參考型別的物件建立時，開始占用記憶體，直到空間不足時 GC 釋放沒有指標指向的物件。無法預測生命週期。   .NET 中這個區塊由 Garbage Collector（GC；垃圾回收；記憶體回收）來提供自動記憶體管理服務。自動記憶體管理（Automatic Memory Management）可以避免一些常見的問題，例如忘記釋放不再使用的物件而造成記憶體流失（Memory Leak，也就是 Stack 中的變數和指標已經移除了，但 Heap 中變數對應的物件沒有被釋放），或嘗試存取已經被釋放的物件而造成錯誤等。\n當第一個參考型別的實例建立（new）時，GC 會依據所需的記憶體大小在 Heap 根位址（base address）上開闢一個空間存放物件，接下來下一個物件的存放位置會與上一個相鄰，下一個再與上一個相鄰\u0026hellip;，依照這個原則依序存放直到沒有足夠的空間為止。\n當 GC 估計記憶體空間不足時，就會將不再使用、沒有指標指向的物件回收，釋放空間，然後將具有指標的物件重新排序壓縮（以複製刪除方式），將可用的空間挪到一起，供後續新增的物件使用。程式中也可以使用 GC.Collect() 建議 GC 進行回收（不代表 GC 會馬上處理），但通常不需要這麼做。\nHeap 中有另外一個區塊用來存放大型物件（Large Object Heap），在這個區塊中，一樣是由 GC 管控記憶體配置，但是當大型物件回收後，其他的物件不會重新排序，以避免大型物件的搬移降低效能。\n當程式建立大型陣列或資料集合（超過 2GB），CLR 無法為他們配置足夠的連續記憶體空間時，會產生 OutOfMemoryException 例外狀況。更多可能導致 OutOfMemoryException 的原因可以參考微軟文件。\nStack vs Heap    項目 Stack Heap     特點 靜態記憶體配置；記憶體配置方式具連續性、可預測 動態記憶體配置；依使用者需求配置記憶體，空間上不需具連續性   結構特性 記憶體陣列；後進先出（LIFO）的資料結構 記憶體區塊，依需求分割儲存各種資料物件，物件存取不存在順序關係   比喻 疊盤子，最後放上去的會最先拿起來  相片牆，照片可任意拿取或重新排列    儲存的資料 實值型別，和參考型別的指標 參考型別的值和封箱的實值型別變數等   記憶體配置速度 快 較慢   可否改變儲存長度 不能 可以   存取性質 不能跨執行緒存取 可跨執行緒存取   何時釋放空間（生命週期） 區域變數離開存取範圍後 沒有指標指向此物件後，由 GC 判斷 Heap 使用需求來規劃清除時機   例外狀況 StackOverflowException OutOfMemoryException    圖解資料型別與記憶體配置 原則：實值型別的值會與對應的變數或成員名稱存放相同記憶體位置，參考型別的值會存在 Heap 中，儲存其對應變數或成員名稱的地方會有這個值的指標。\n以下共用的 struct 和 class 程式碼：\n1 2 3 4 5 6 7 8 9 10 11  struct MyStruct { public int Param { get; set; } public MyClass InnerClass { get; set; } } class MyClass { public int Param { get; set; } public MyStruct InnerStruct { get; set; } }   1. 實值型別（簡單型別）區域變數 1 2 3 4 5 6 7 8 9  int a; a = 10; int b = a; int c = Add(a, b); public int Add(int x, int y) { return x + y; }    2. 參考型別（類別）區域變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14  MyClass myclass1 = new MyClass() { Param = 10 }; MyClass myclass2 = myclass1; BeNull(myclass1); ModifyClassParamTo50(myclass2); public void BeNull(MyClass s) { s = null; //不會影響原本的物件的指標 } public void ModifyClassParamTo50(MyClass s) { s.Param = 50; }    3. 參考型別（字串）區域變數 1 2 3 4 5 6 7 8 9 10  string s1 = \u0026#34;ABC\u0026#34;; string s2 = s1; s2 = \u0026#34;XYZ\u0026#34;; string s3 = StringConcatenate(s1, s2); public string StringConcatenate(string x, string y) { x += \u0026#34;@@\u0026#34;; return x + y; }    4. Struct 區域變數（含參考型別成員） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  MyStruct mystruct1 = new MyStruct() { Param = 10 }; MyStruct mystruct2 = new MyStruct() { Param = 10 }; Console.WriteLine(\u0026#34;4-1. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True  ModifyStructParamTo50(mystruct1); //作為引數會複製一份資料給方法使用 Console.WriteLine(\u0026#34;4-2. mystruct1.Param = \u0026#34; + mystruct1.Param); //10  MyClass myclass = new MyClass(); mystruct1.InnerClass = myclass; Console.WriteLine(\u0026#34;4-3. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //False mystruct2.InnerClass = myclass; Console.WriteLine(\u0026#34;4-4. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True  ModifyClassParamTo50(mystruct2.InnerClass); Console.WriteLine(\u0026#34;4-5. mystruct1.InnerClass.Param = \u0026#34; + mystruct1.InnerClass.Param); //50 Console.WriteLine(\u0026#34;4-6. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True Console.WriteLine(\u0026#34;4-7. myclass.Equals(mystruct1.InnerClass)：\u0026#34; + myclass.Equals(mystruct1.InnerClass)); //True  public void ModifyStructParamTo50(MyStruct s) { s.Param = 50; //修改複製來的資料，不影響原本 Struct 的值 } public void ModifyClassParamTo50(MyClass s) { s.Param = 50; }    5. 參考型別區域變數（含 Struct 成員） 1 2 3  MyClass myClass1 = new MyClass() { Param = 10, InnerStruct = new MyStruct() }; MyClass myClass2 = new MyClass() { Param = 10, InnerStruct = new MyStruct() }; Console.WriteLine(\u0026#34;5-1. myClass2.Equals(myClass1)：\u0026#34; + myClass2.Equals(myClass1)); //False    6. 實值型別封箱 Boxing 1 2  MyStruct myStruct = new MyStruct(); object boxed = myStruct;    7. 類別陣列 1  MyClass[] classArray = new MyClass[] { new MyClass(), new MyClass()};    8. Struct 陣列 1  MyStruct[] structArray = new MyStruct[] { new MyStruct(), new MyStruct()};    總結：Struct 使用時機 和 class 比較，其實 struct 的限制頗多，除了作為實值型別需考量其記憶體的使用外，其他還有 struct 只能實作介面，不能繼承或抽象化，所以只有有限的多型性。\n了解 struct 的特性後，總算可以歸納 struct 使用的時機了😂\n Struct 使用時機：\n 會一直重複使用的小型的資料結構 類別中希望限定只能唯讀的成員 作為方法引數，但不希望值本身受方法運算結果影響 應盡量避免 Boxing / Unboxing   相關連結：  [C#Corner] Stack Vs Heap Memory - C# [C#Corner] Working With Static In C# [CODE PROJECT] Static Keyword Demystified [stack overflow] Where are all the static members stored? [Micorsoft Docs] Automatic Memory Management [Micorsoft Docs] C# 型別系統  Struct V.S Class 兩者之間差異 Why is List 15 Times Faster to Allocate than List in C# [Book] Head First C#, 4th Edition  ","description":"本篇整理 .NET「通用語言運行庫」（Common Language Runtime）如何管理和配置記憶體資源，以存取程式運行中所用的實值型別（value types）或參考型別（reference types）變數資料。","id":0,"section":"posts","tags":["CLR","stack","heap","value types","reference types","struct"],"title":"CLR、記憶體管理與資料型別","uri":"https://www.zoeydc.com/zh/posts/2021-07-10-clr_stack_heap_csharp_types/"},{"content":"有時後開發中需要測試不同環境或裝置開啟網站的差異，而為了方便偵錯，可以讓 IIS Express 啟動的網站允許外部連線進來。\n⼀、系統環境  Windows Server 2012 Visual Studio 2012  二、取得本機端 IP 以 ipconfig 取得本機端的 IP（例如 192.168.40.1）\n三、以系統管理員⾝分開啟 Visual Studio 一定要用系統管理員⾝分執⾏ Visual Studio，因為更改成非 localhost 的繫結設定後需要系統管理員權限才能執⾏ IIS Express。\n如果沒有用系統管理員執行，可能會跳出以下訊息：\n 四、設定 applicationhost.config 開始偵錯，IIS Express執⾏後，取得網站名稱，並找到組態檔 applicationhost.config。\n   （VS 2012 在「我的文件」中：「%USERPROFILE%\\My Documents\\IISExpress\\config\\applicationhost.config」；VS 2019 在「⽅案資料夾.vs\\專案名稱\\config\\applicationhost.config」。）\n 開啟檔案後，依照網站名稱找到對應的設定，修改原本的繫結設定，將 localhost 改成本機的 IP（例如 bindingInformation=\u0026quot;*:62754:localhost\u0026quot; 改為 bindingInformation=\u0026quot;*:62754:192.168.40.1\u0026quot;），然後存檔。\n1 2 3 4 5 6 7 8 9  \u0026lt;site name=\u0026#34;TestSite(1)\u0026#34; id=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;application path=\u0026#34;/\u0026#34; applicationPool=\u0026#34;Clr4IntegratedAppPool\u0026#34;\u0026gt; \u0026lt;virtualDirectory path=\u0026#34;/\u0026#34; physicalPath=\u0026#34;C:\\TestSite\\TestSite\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;bindings\u0026gt; \u0026lt;binding protocol=\u0026#34;http\u0026#34; bindingInformation=\u0026#34;*:62754:192.168.40.1\u0026#34; /\u0026gt; \u0026lt;binding protocol=\u0026#34;https\u0026#34; bindingInformation=\u0026#34;*:44372:192.168.40.1\u0026#34; /\u0026gt;  \u0026lt;/bindings\u0026gt; \u0026lt;/site\u0026gt;   五、設定輸入規則 控制台→Windows防火牆→進階設定→輸入規則→新增規則→選擇連接埠→設定要開放的\nport（以上面例子來說就是 62754 和 44372）→完成設定\n 六、重新啟動網站 關閉 IIS Express，結束偵錯（但不要關閉 VS），然後再重新進入偵錯，啟動網站。\n七、手機端測試連線 手機使⽤對應的 URL，例如 http://192.168.40.1:62754，即可瀏覽。\n 個⼈偏好，在測試完成後，會將 applicationhost.config 繫結改回來 localhost，不然重開專案後，繫結可能重設，網站名稱和編號會⼀直增加 （例如 TestSite → TestSite(1) → TestSite(2) → …）\n 備註：狀況排解 以下是我設定時曾經遇到的狀況和解決方法：\n狀況⼀、The site can’t be reached.（無法連上這個網站） → 檢查輸入規則是否設定成功。\n 狀況⼆、Bad Request – Invalid Hostname → 檢查 applicationhost.config 的繫結設定\n 相關連結：  Using Custom Domains With IIS Express  ","description":"有時開發中需要測試不同環境或裝置開啟網站的差異，而為了方便偵錯，可以讓 IIS Express 啟動的網站允許外部連線進來。","id":1,"section":"posts","tags":["IIS Express","debug"],"title":"讓 IIS Express 允許外部連接（區網內手機或其他電腦等）","uri":"https://www.zoeydc.com/zh/posts/2021-06-27-enable_external_access_on_iis_express/"},{"content":"當桌⾯應⽤程式需要網路資源時，可以⽤ HttpClient 或 WebClient 等發送 HTTP 請求，但有時反過來想要開放桌⾯程式的資源供外界使⽤呢？這時就可以⽤ Self Host 的⽅式，不需要依附 IIS 就可以在程式裡掛載 Web API，為程式和外界聯繫提供⼀個管道。\n本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。\n一、系統環境  Windows 10 Visual Studio 2019 .NET Framework 4.7.2  ⼆、建立 Startup.cs，Web API 的進入點 ⾸先，安裝套件：\n Install-Package Microsoft.AspNet.WebApi.OwinSelfHost -Version 5.2.7\n （OWIN 為 .NET Framework 4.5 以上使⽤， 4.0 ⽤ Microsoft.AspNet.WebApi.SelfHost 裝載 Web API）\n接著新增類別（或 OWIN 啟動類別）Startup.cs，設定路由規則，讓 Web API 以此規則在 OWIN 上運⾏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  using System.Web.Http; //using System.Web.Http.Cors; using Microsoft.Owin; using Owin; [assembly: OwinStartup(typeof(SelfHostConsole.Startup))] namespace SelfHostConsole { public class Startup { public void Configuration(IAppBuilder app) { // 如需如何設定應用程式的詳細資訊，請瀏覽 https://go.microsoft.com/fwlink/?LinkID=316888  // Configure Web API for self-host.  HttpConfiguration config = new HttpConfiguration(); config.Routes.MapHttpRoute( name: \u0026#34;DefaultApi\u0026#34;, routeTemplate: \u0026#34;api/{controller}/{id}\u0026#34;, defaults: new { id = RouteParameter.Optional } );  //Enable CORS  //config.EnableCors(new EnableCorsAttribute(\u0026#34;*\u0026#34;, headers: \u0026#34;*\u0026#34;, methods: \u0026#34;*\u0026#34;));  app.UseWebApi(config);  } } }   如果網站需要跨域資源共享（CORS），則需安裝 CORS 套件，並啟用上述第 2 和 22 ⾏：\n Install-Package Microsoft.AspNet.WebApi.Cors -Version 5.2.7\n 接下來在 Program.cs 裡設定執⾏程式時啟動 Web API host：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using Microsoft.Owin.Hosting; using System; namespace SelfHostConsole { class Program { static void Main(string[] args) { string baseAddress = \u0026#34;http://localhost:55000/\u0026#34;; Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(url: baseAddress)) { Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); }  } } }   此時若以 Postman 測試 Get 訪問 http://localhost:55000/ 會收到 404 Not Found，⽽不是出現 Error: connect ECONNREFUSED 127.0.0.1:55000 這樣的訊息，表⽰這時候 Web API 的基本架構已經完成了。\n三、加入 Controller 依照習慣取代配置（Convention over Configuration）的原則，Controller 以 Controller 結尾就可以被找到，這邊簡單加個 TestController。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System.Collections.Generic; using System.Web.Http; namespace SelfHostConsole { public class TestController : ApiController { private static List\u0026lt;MyModel\u0026gt; list = new List\u0026lt;MyModel\u0026gt;() { new MyModel(){Name=\u0026#34;name1\u0026#34;, Value=\u0026#34;value1\u0026#34;}, new MyModel(){Name=\u0026#34;name2\u0026#34;, Value=\u0026#34;value2\u0026#34;}, }; // GET api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Get() { return list; } // GET api/test/1  public MyModel Get(int id) { if (id \u0026lt; 0 || id \u0026gt;= list.Count) return null; return list[id]; } // POST api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Post([FromBody] MyModel newData) { list.Add(newData); return list; } } public class MyModel { public string Name { get; set; } public string Value { get; set; } } }   這樣 Web API 就可以運作了。\n⽤ Postman 測試⼀下，運作正常。\n 如果 Postman 收到以下的訊息，確認⼀下是否有將 Controller 設為 public class。\n1 2 3 4  { \u0026#34;Message\u0026#34;: \u0026#34;No HTTP resource was found that matches the request URI \u0026#39;http://localhost:55000/api/test\u0026#39;.\u0026#34;, \u0026#34;MessageDetail\u0026#34;: \u0026#34;No type was found that matches the controller named \u0026#39;test\u0026#39;.\u0026#34; }   四、安裝 SSL 憑證，啟⽤ HTTPS 若要啟⽤ HTTPS，程式碼網址部分直接修改成 https 即可。除此之外環境要安裝 SSL 憑證。\n1. 建立 SSL 憑證 這邊⽤ OpenSSL 建立憑證，取得 crt 和 pfx 檔後，匯入⾃簽憑證到「受信任的根憑證授權單位」和「伺服器憑證」。\n以系統管理員⾝分執⾏命令提⽰字元，其中 CertPassword 取代為在建立 pfx 檔時所輸入的密碼。：\n1  certutil -f -p CertPassword -importpfx \u0026#34;server.pfx\u0026#34;   2. 取得憑證指紋（Thumbprint） 在「開始」功能表搜尋 mmc 或 certlm.msc ，進到憑證管理介⾯，在「個⼈」或「受信任的根憑證授權單位」中找到匯入的憑證名稱，快點兩下進到「詳細資料」畫⾯，將憑證指紋記錄下來。（也可⽤ openssl 取得憑證指紋)\n 3. 將 SSL 憑證和 Port 綁定 以系統管理員⾝分執⾏命令提⽰字元，其中 certhash 為上⼀步驟得到的憑證指紋，appid 則填入任意⼀組 GUID。：\n1  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a}   4. 進⾏測試 Postman 測試時可能會出現 Error: self signed certificate，是因為憑證檢核時⾃簽憑證無法過關，需要在設定裡將「SSL certificate verification」關閉（建議測試完後恢復進⾏檢核）。正常來說可以得到和先前⼀樣的結果，除了網址 http 現在換成 https。\n五、繫結多個 IP 或域名 在 Program.cs 啟動 Web API 是使用 WebApp.Start(url: baseAddress) 來設定網址，觀察它的 Metadata，Start 方法除了傳入 url 網址外，還有另一個傳入 StartOptions 的多載，裡面有個 Urls 的 Property，說明為「A list of url prefixes to listen on. Overrides port.」，所以就是從這邊下手了。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Program { static void Main(string[] args) { StartOptions options = new StartOptions(); options.Urls.Add(\u0026#34;https://localhost:55000/\u0026#34;); options.Urls.Add(\u0026#34;http://localhost:55001/\u0026#34;);  Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(options: options)) \t{ Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); } } }   這樣就完成了多個 IP 的繫結。\n補充 1. SSL 憑證安裝刪除查詢 參考「⽤ certutil 新增刪除查詢 SSL 憑證」。\n2. SSL 繫結 Port 及刪除、查詢繫結 1 2 3 4  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a} netsh http delete sslcert ipport=0.0.0.0:55000 netsh http show sslcert netsh http show sslcert ipport=0.0.0.0:55000   3. 在 Windows Service 中啟動 Web API 覆寫 OnStart 與 OnStop 方法時分別建立和釋放 Web API 資源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using Microsoft.Owin.Hosting; using System; using System.ServiceProcess; namespace SelfHost { public partial class SelfHostService : ServiceBase { private IDisposable _server = null;  public SelfHostService() { InitializeComponent(); } protected override void OnStart(string[] args) { _server = WebApp.Start\u0026lt;Startup\u0026gt;(\u0026#34;https://localhost:55000/\u0026#34;);  } protected override void OnStop() { if (_server != null) { _server.Dispose(); }  base.OnStop(); } } }   相關連結：  [Microsoft Docs] ⾃我裝載 ASP.NET Web API 1 （C#） [Microsoft Docs] 使⽤ OWIN ⾃我裝載 ASP.NET Web API [Microsoft Docs] 如何：使⽤ MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] 作法：使⽤ SSL 憑證設定連接埠 [WILL保哥] 如何使⽤ OpenSSL 建立開發測試⽤途的⾃簽憑證 (Self-Signed Certificate) [⿊暗執⾏緒] PostMan 無法連線 IIS Express 網站 OWIN WebAPI Service example ","description":"本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。","id":2,"section":"posts","tags":["OWIN","Self Host","ASP.NET","Web API","SSL","IIS"],"title":"免 IIS，⽤ OWIN 架設輕量級 ASP.NET Web API","uri":"https://www.zoeydc.com/zh/posts/2021-06-13-owin-selfhost-webapi-console/"},{"content":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。\n前置作業：查詢憑證指紋（Fingerprint、Thumbprint） 本篇憑證是⽤ OpenSSL 所產⽣的 crt 和 pfx 檔，另外刪除或查詢憑證資訊時需⽤到憑證指紋，可 (1) 直接⽤ OpenSSL 取得，或 (2) 匯入憑證後進到 MMC 介⾯查詢 。\n(1) OpenSSL 將取得類似「SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB」的⼀串文字，使⽤時取「Fingerprint=」之後的文字並將冒號去除。\n以命令提示字元執行查詢：\n1 2 3 4 5 6 7 8 9  REM CertificateFile 為憑證檔名稱 REM 查詢憑證指紋 \u0026gt; openssl x509 -in CertificateFile.crt -fingerprint -noout SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB REM 查詢序號 \u0026gt; openssl x509 -in CertificateFile.crt -serial -noout serial=6D53BD345F83AF5C3CFC1CE36C2540273C74B607   (2) MMC 介面  受信任的根憑證授權單位（root） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  REM 匯入 certutil -addstore -f \u0026#34;ROOT\u0026#34; CertificateFile.crt REM 上述匯入憑證後，如要再匯入密鑰（⼀般不需要） REM CertPassword 為產⽣ pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx root \u0026#34;CertificateFile.pfx\u0026#34; REM 依憑證指紋進行刪除 certutil -delstore root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有受信任的根憑證 certutil -store root REM 針對憑證指紋進⾏查詢 certutil -store root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   個⼈存放區（my） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  REM 匯入憑證（無密鑰） certutil -addstore -f my CertificateFile.crt REM 匯入憑證及密鑰到個人存放區，「同時」也會新增到受信任的根憑證授權單位 root REM CertPassword 為產生 pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx my \u0026#34;CertificateFile.pfx\u0026#34; (certutil -f -p CertPassword -importpfx \u0026#34;CertificateFile.pfx\u0026#34;) REM 依憑證指紋進行刪除 REM 只刪除在個人存放區 \u0026#34;my\u0026#34; 的憑證，刪除在 \u0026#34;root\u0026#34; 的憑證需要另外執行 certutil -delstore my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有個人憑證 certutil -store my REM 針對憑證指紋進行查詢 certutil -store my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   備註1：若匯入 pfx 檔到個人存放區，則在 IIS 的伺服器憑證中也可以查詢到。\n備註2：若是從 IIS 伺服器憑證匯入憑證到個人存放區，那就只會在個人存放區有，不會同時新增到 root。\n備註3：若是管理「目前的使用者」（Current User）的憑證，在 certutil 後加上 -user 即可，例如：certutil -user -addstore -f my CertificateFile.crt。「目前的使用者」的憑證會繼承「本機電腦」所有的憑證，除了在「本機電腦」的「個人存放區」的憑證（參考連結3）。\n相關連結：  [Microsoft Docs] 如何：使用 MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] certutil [Microsoft Docs] Local Machine and Current User Certificate Stores ","description":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。","id":3,"section":"posts","tags":["certutil","SSL"],"title":"⽤ certutil 新增刪除查詢 SSL 憑證","uri":"https://www.zoeydc.com/zh/posts/2021-06-04-certutil-store-ssl/"},{"content":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定（例如資料庫連線字串、系統資源對應路徑等），這些繁瑣的設定若是每次都⼿動修改實在容易出錯，⽽ Visual Studio 本⾝就有 Web.config 組態檔轉換功能，好好利⽤可以⼤⼤節約時間並降低錯誤機率，更能專注在開發本⾝。\n專案建立好時預設有兩個組態 Debug 和 Release，⼀般我會再建立⼀個 Test 組態在測試環境使⽤，所以本篇記錄 1. 如何新增組態和與之對應的 Web.config 設定檔，和 2. 設定 Web.config 轉換內容。\n⼀、前置作業  以 ASP.NET MVC 的預設範本建立專案（Visual Studio 2019） 檢視預設組態設定：預設的 Debug 和 Release 組態各有⼀個對應的 config 檔（Web.{組態名稱}.config）   ⼆、新增組態設定與設定檔 從「組態管理員」中新增「Test」組態後，在⽅案總管中會發現 Web.Test.config 檔案並沒有⾃動產⽣，需要⼿動「新增設定轉換」（Add Transform），檔案就會出現了。\n  三、設定不同組態發⾏時對應的 Web.config 接下來要編輯這些檔案裡⾯的內容了！了解語法之前來快速看⼀下⼀個簡單的轉換範例和呈現的效果。\n範例與效果 就以發佈 Release 組態來說，假設原本的 Web.config 有個參數 Env：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Dev\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 對照在 Web.Release.config 的 Env 參數設定，除了將 value 設為 Release 外，另外加了 xdt:Transform 和 xdt:Locator 屬性（屬性詳細說明⾒下方語法詳述），如下：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Release\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(key)\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 實際發佈時， Env 的設定就會轉換為 Release了。\n或者可以⽤內建的預覽⼯具發佈前預先檢視結果與差異處：\n  ↑ 左邊是原始的設定檔，右邊則是轉換後的結果，差異處也都⾃動標記了。\n語法詳述（Web.config Transformation Syntax） 回顧⼀下 Web.Release.config 的原始內容，或者新建的 Web.Test.config 也有相同的內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!-- 如需使用 web.config 轉換的詳細資訊，請前往 https://go.microsoft.com/fwlink/?LinkId=125889 --\u0026gt; \u0026lt;configuration xmlns:xdt=\u0026#34;http://schemas.microsoft.com/XML-Document-Transform\u0026#34;\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;SetAttributes\u0026#34; 轉換只會在 \u0026#34;Match\u0026#34; 定位程式找到 值為 \u0026#34;MyDB\u0026#34; 的屬性 \u0026#34;name\u0026#34; 時，才將 \u0026#34;connectionString\u0026#34; 的值變 更為使用 \u0026#34;ReleaseSQLServer\u0026#34;。 \u0026lt;connectionStrings\u0026gt; \u0026lt;add name=\u0026#34;MyDB\u0026#34; connectionString=\u0026#34;Data Source=ReleaseSQLServer;Initial Catalog=MyReleaseDB;Integrated Security=True\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(name)\u0026#34;/\u0026gt; \u0026lt;/connectionStrings\u0026gt; --\u0026gt; \u0026lt;system.web\u0026gt; \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;Replace\u0026#34; 轉換將會取代 web.config 檔案 的整個 \u0026lt;customErrors\u0026gt; 區段。 請注意，因為在 \u0026lt;system.web\u0026gt; 節點之下 只有一個 customErrors 區段，所以不需要使用 \u0026#34;xdt:Locator\u0026#34; 屬性。 \u0026lt;customErrors defaultRedirect=\u0026#34;GenericError.htm\u0026#34; mode=\u0026#34;RemoteOnly\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34;\u0026gt; \u0026lt;error statusCode=\u0026#34;500\u0026#34; redirect=\u0026#34;InternalError.htm\u0026#34;/\u0026gt; \u0026lt;/customErrors\u0026gt; --\u0026gt; \u0026lt;/system.web\u0026gt; \u0026lt;/configuration\u0026gt;   和⼀般 Web.config 不同的是，它引⽤了 XML-Document-Transform 命名空間（第 3 ⾏），對應到 xdt 前置詞的使⽤（xdt:Locator 和 xdt:Transform），⽤來處理元素和屬性的轉換；xdt 前置詞在轉換後的文件中不會出現。\n【Locator】 ⽤來定位要轉換的元素位置，為非必要屬性，若未設定時則找出所有同層級元素，再依 Transform 屬性決定轉換模式。Locator 有三種設定⽅式。\nxdt:Locator=\u0026#34;Condition(XPath 運算式)\u0026#34; 範例：xdt:Locator=\u0026#34;Condition(@name=\u0026#39;oldname\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;)\u0026#34; 說明：找到符合 XPath 運算式條件的元素。例如屬性 name 為 oldname 或 providerName 為 oldprovider 的所有元素。\nxdt:Locator=\u0026#34;Match(屬性1,屬性2,屬性3,…)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;Match(name, providerName)\u0026#34; 說明：找到與所列屬性的值「皆」相同的元素。例如屬性 name 為 AWLT 且 providerName 為 newprovider 的所有元素。\nxdt:Locator=\u0026#34;XPath(XPath 運算式)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT2\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;XPath(/configuration/connectionStrings/add[@name=\u0026#39;AWLT\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;])\u0026#34;/\u0026gt; 說明：完全使⽤ XPath 運算式（絕對路徑）來尋找元素，不以元素現在的位置為參考。例如即使將上述標籤放到 \u0026lt;appSettings\u0026gt; 元素下或直接放在 \u0026lt;configuration\u0026gt; 底下，其依然會找到 connectionStrings 中，符合 name 為 AWLT 或 providerName 為 oldprovider 的所有元素。\n【Transform】 說明元素屬性該如何轉換，有八種⽅式。\nxdt:Transform=\u0026#34;Replace\u0026#34; 說明：以轉換檔（Web.{組態名稱}.config）中的元素取代 Locator 屬性在 Web.config 中會找到的元素。如果找到多個元素，只會取代第⼀個。\nxdt:Transform=\u0026#34;Insert\u0026#34; 說明：將轉換檔的元素加入 Web.config 中 Locator 所定義的同層級的元素區域中的最後⾯。\nxdt:Transform=\u0026#34;InsertBefore(XPath 運算式)\u0026#34; 說明：將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素前⾯（不是 Locator 所指的元素，在此處 Locator 沒有作⽤）。\n1 2 3  \u0026lt;authorization\u0026gt; \u0026lt;allow roles=\u0026#34;Admins\u0026#34; xdt:Transform= \u0026#34;InsertBefore(/configuration/system.web/authorization/deny[@users=\u0026#39;*\u0026#39;])\u0026#34; /\u0026gt; \u0026lt;/authorization\u0026gt;   上⾯範例設定轉換時在「拒絕所有使⽤者」的項⽬前，插入「允許系統管理者」的授權。\nxdt:Transform=\u0026#34;InsertAfter(XPath 運算式)\u0026#34; 說明：和 InsertBefort 相反，是將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素後⾯。\nxdt:Transform=\u0026#34;Remove\u0026#34; 說明：移除 Locator 找到的第⼀個元素。\nxdt:Transform=\u0026#34;RemoveAll\u0026#34; 說明：移除 Locator 找到的所有元素。\nxdt:Transform=\u0026#34;RemoveAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，移除所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆移除。\n1  \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;   Web.Release.config 預設就會移除 compilation 的 debug 屬性，以提⾼發⾏時程式運⾏的效能。（原始內容第 16 ⾏）\nTransform=\u0026#34;SetAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，依照轉換檔的屬性設定所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆依轉換檔進⾏設定。\n參考網址：  [Microsoft Docs] 使用 Visual Studio 的 ASP.NET Web 部署： Web.config 檔轉換 [Microsoft Docs] Web.config Transformation Syntax for Web Application Project Deployment ","description":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定，若能善用 Visual Studio 本⾝組態檔的轉換功能，可以⼤⼤節約時間並降低錯誤機率，更能專注在開發上。本篇記錄 (1) 如何新增組態和 Web.config 設定檔，和 (2) 設定 Web.config 轉換內容。","id":4,"section":"posts","tags":["visual studio","config transforms"],"title":"Visual Studio 發佈專案時⾃動轉換組態對應的 Web.config","uri":"https://www.zoeydc.com/zh/posts/2021-05-29-visual-studio-webconfig/"},{"content":"一直有建部落格的想法，也試過一些部落格平台和 WordPress，覺得平台上開站雖然方便，只要註冊帳號就好，但是版型調整方式有限，無法將網站改成符合自己心意的模樣，相較而言，WordPress 自由度很高，不過架構也相對複雜，還需要管理外掛和資料庫，有點麻煩，不太符合單純寫文章的想法，經過一番搜尋後，決定用靜態網站來架設我的部落格！\n雖然 GitHub Pages 推薦使用 Jekyll 生成靜態網頁，但在 Windows 環境下 Jekyll 似乎比較不友善，而 Hugo 入門相對容易、官方文件有完整的教學，還有編譯速度快等優點，眾多因素考慮下，我選擇了 Hugo。\n不過還是花了一些時間才把網站搞定，所以決定要記錄一下整個架站過程，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域，以供參考。\n 以下 {username} 為 GitHub 帳號名，{主題名稱} 為所選的佈景主題名稱，例如我的是 zzo。\n 本機端開發環境的建置 本機環境  作業系統：Windows 10\n Hugo 可以安裝在 Windows、Linux、macOS 等作業系統，Linux 或 macOS 的安裝方式請參考官方文件。\n以下建置過程預設環境已安裝 Git，也註冊 GitHub 帳號並建立名稱為 {username}.github.io 的 repo 了。\n安裝套件管理器 CHOCOLATEY 以系統管理員身分執行 PowerShell，執行以下指令：\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))   若安裝無誤，執行 choco 可得版本資訊，例如：\n1 2 3  \u0026gt; choco Chocolatey v0.10.15 Please run \u0026#39;choco -?\u0026#39; or \u0026#39;choco \u0026lt;command\u0026gt; -?\u0026#39; for help menu.   安裝 Hugo、建立新網站 PowerShell 繼續執行：\n1  choco install hugo -confirm   如果選擇的主題需要擴充套件 Sass/SCSS 版本，執行：\n1  choco install hugo-extended -confirm   若不確定是否需要擴充套件的話，可以先跳過，之後執行 hugo server 出現以下類似錯誤時再安裝 hugo-extended：\n ERROR 2021/05/08 16:44:51 TOCSS: failed to transform \u0026ldquo;main_parsed.scss\u0026rdquo; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS.\n 安裝完 Hugo 後，就可以建立新網站了。\n1 2  cd myfolder ## Hugo 會在此資料夾底下新建一個資料夾 hugo new site mywebsite ## 建立網站 \u0026amp; 資料夾 mywebsite   這個資料夾底下會建立 archetypes、content、static、themes 等資料夾，但 themes 裡面沒有預設的佈景主題，需要自己安裝。\n可以到所選的主題的 GitHub repo 下載檔案解壓縮到 themes/{主題名稱}/ 或是用 git submodule 安裝（以下以 zzo 主題為例）。\n1 2 3  cd mywebsite ## 進入網站資料夾 git init git submodule add https://github.com/zzossig/hugo-theme-zzo themes/zzo   安裝完成後，官方文件使用指令新增組態檔 config.toml：\n1  echo theme = \\\u0026#34;zzo\\\u0026#34; \u0026gt;\u0026gt; config.toml   但建議直接複製範例網站，到 themes/{主題名稱}/exampleSite/ 目錄下複製整個資料夾內容貼到 mywebsite 根目錄，再來修改組態檔，尤其有些佈景主題的組態檔結構複雜，只新增 config.toml 可能會缺少某些參數而編譯失敗。\n如果要自訂 layouts 或 i18n 的內容，也從 themes/{主題名稱}/ 下複製資料夾到根目錄後進行修改。\n先來設定 config.toml 的 baseURL 和網站語言等：\n1 2 3 4 5 6 7  # 如果使用 GitHub Pages 預設域名 baseURL = \u0026#34;https://{username}.github.io/\u0026#34; # 自訂域名範例 baseURL = \u0026#34;https://www.customdomainname.com/\u0026#34; languageCode = \u0026#34;zh-tw\u0026#34; title = \u0026#34;My Site Name\u0026#34; #自訂任意名稱   本機端啟動網站：\n以 hugo servre 方式啟動網站，Hugo 會隨時偵測檔案的異動來更新網頁，到預設網址 http://localhost:1313/ 就可以看到最新的內容，關閉網站用 CTRL+C 。\n1  hugo server   上傳到 Github Pages 發布網站 官方文件使用 GitHub Action 來佈署網站（方法一），但如果不希望將網站的原始碼放到網路上，可以選擇只提交最後編譯好的靜態網頁（方法二）。\n方法一：建立 gh-pages 分支 先確定使用的 Hugo 版本，以及是否安裝擴充套件。\n1 2  \u0026gt; hugo version hugo v0.83.1-5AFE0A57+extended windows/amd64 BuildDate=2021-05-02T14:38:05Z VendorInfo=gohugoio   將整個資料夾 Push 到 Github repo （{username}.github.io）：\n1 2 3 4 5 6  ## 現在路徑為 myfolder/mywebsite/ git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git remote add origin https://github.com/{username}/{username}.github.io.git git push -u origin main   再到 GitHub 新增 gh-pages.yml 檔案。\n  在上圖步驟 2 時，將 gh-pages.yml 內容用以下內容取代，其中 hugo-version 和 extended 再依需求進行設定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  name:github pageson:push:branches:- main # Set a branch to deployjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;# \u0026#39;0.83.1\u0026#39;# extended: true # 有用擴充套件則將 # 移除- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public  Commit 完成後，檢查 workflow 是否順利。（之後每次 main 分支有 commit 就會有新的 workflow 自動產生，重新編譯發布網站）\n  全部都 ✔ 表示順利完成編譯囉。\n接下來設定 GitHub Pages 要讀取 gh-pages 分支的檔案，設定完就可以到 https://{username}.github.io 瀏覽網站成果。\n 方法二：上傳 Public 資料夾 先以 hugo 產生靜態 html 檔案，成功的話會在 mywebsite/public/ 裡面看到檔案，再將 public 資料夾 push 到 GitHub。\n1 2 3 4 5 6 7 8 9  ## 現在路徑為 myfolder/mywebsite/ git submodule add https://github.com/{username}/{username}.github.io.git public hugo # 產生靜態 html 檔案 cd public git status # 檢查 public 資料夾，應只看到 public 中新增的檔案 git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git push -u origin main   參考上圖到 GitHub Pages 設定要讀取的分支為 main，就可以訪問 https://{username}.github.io。\n自訂網域 GitHub 官方建議先在 GitHub 中設定 CNAME，再到 DNS 供應商設定 DNS 紀錄。\n新增檔案 CNAME 在 GitHub 網站介面中可以設定網域名，其機制是在 Pages 的目標分支根目錄下加上 CNAME，但是這樣每次有檔案更新 CNAME 就會被覆蓋掉，要再重新設定，所以 Hugo 網站是要新增 CNAME 在 static 資料夾中，這樣編譯後，檔案會自動放在網站根目錄下，GitHub 就能以此偵測自訂域名。\nCNAME 檔案（無副檔名）內容就只放自訂的網域名（例如 www.customdomainname.com）。\n設定 DNS 到 DNS 供應商設定 DNS 紀錄，增加 4 筆 A Record 和 1 筆 CNAME Record（以 www 為例）。\n   Type Host Value     A Record @ 185.199.108.153   A Record @ 185.199.109.153   A Record @ 185.199.110.153   A Record @ 185.199.111.153   CNAME Record www {username}.github.io    更改 repo 名稱（非必要） 最後可以將 repo 名稱改為現在的網域，然後將 Pages 的 Enforce HTTPS 取消再重新勾選，讓 SSL 憑證重新產生。\n結論 基本上一步一步執行就可以完成 Hugo 網站建置，如果一開始就打算自訂網域也可以先新增 CNAME 檔案以及用自訂網域作 repo 名稱來簡化步驟！\n參考網址：  Hugo Docs GitHub Docs 自訂網域  其他：  編寫 Markdown 文件 ","description":"使用 Hugo 在 GitHub Pages 架設靜態網站，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域。","id":5,"section":"posts","tags":["Hugo","Static Site Generator","Git","GitHub Pages"],"title":"網站開張！在 GitHub Pages 架設 Hugo 靜態網站","uri":"https://www.zoeydc.com/zh/posts/2021-05-23-hugo-website_github-pages_custom-domain/"}]