[{"content":"本篇整理 switch 的各種模式比對（至 C# 9.0），主要參考微軟文章(Patterns)。\n測試環境：\n .NET Framework 4.7.2 (C# 7.3)\n.NET 6.0 (C# 10)\n 如果標記 C# 9.0，預設在 .NET 5.x 以上才可使用；C# 8.0 則是 .NET Core 3.x 後可以用。\n基本架構：執行運算式，由上而下檢查執行結果符合哪個狀況，再執行裡面的陳述式。\n1 2 3 4 5 6 7 8 9 10 11 12  switch (運算式) { case 狀況一: Console.WriteLine(\u0026#34;狀況一\u0026#34;); break; case 狀況二: Console.WriteLine(\u0026#34;狀況二\u0026#34;); break; default: //其他狀況  Console.WriteLine(\u0026#34;其他\u0026#34;); break; }   Declaration pattern 宣告模式 (C# 7.0) 當運算結果不為 null 時，檢查此結果的 runtime 型別，如果可找到對應的狀況，則轉型此結果並指派給宣告的變數。如果運算結果有可能為 null，可增加狀況 null 的檢查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static void ShowTypeAndValue(object obj) { switch (obj) { case int n: Console.WriteLine($\u0026#34;int:{n}\u0026#34;); break; case string s: Console.WriteLine($\u0026#34;string:{s}\u0026#34;); break; case null: throw new ArgumentNullException(nameof(obj)); default: throw new ArgumentException(\u0026#34;Unknown type\u0026#34;, nameof(obj)); } }   宣告模式也可以用在運算結果是可為 Null 的實質型別變數，檢查其基礎類型；或是 boxed 的實質型別，存在某轉型方式。\n如果只檢查型別，不需要使用轉型後的變數，可用 _ 替代宣告的變數名稱，或是在 C# 9.0 後可用「類型模式」。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static void ShowType(object obj) { switch (obj) { case int _: Console.WriteLine($\u0026#34;int\u0026#34;); break; case string _: Console.WriteLine($\u0026#34;string\u0026#34;); break; case null: throw new ArgumentNullException(nameof(obj)); default: throw new ArgumentException(\u0026#34;Unknown type\u0026#34;, nameof(obj)); } }   Type pattern 類型模式（C# 9.0） 類似宣告模式，但是只想檢查運算結果的型別時可使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static void ShowType2(object obj) { switch (obj) { case int: Console.WriteLine($\u0026#34;int\u0026#34;); break; case string: Console.WriteLine($\u0026#34;string\u0026#34;); break; case null: throw new ArgumentNullException(nameof(obj)); default: throw new ArgumentException(\u0026#34;Unknown type\u0026#34;, nameof(obj)); } }   Constant pattern 常數模式 (C# 7.0) 檢查運算結果是否符合指定的狀況，而這些狀況會是常數的形式（任何的常數，例如整數、char、字串、布林值、Enum、常數欄位或是 null 等，C# 9.0 後可以用 not null）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static decimal GetDiscount(int itemCount) { switch (itemCount) { case 1: return 1m; case 2: return 0.95m; case 3: return 0.9m; case 4: return 0.8m; default: throw new ArgumentException($\u0026#34;Not supported number of items: {itemCount}\u0026#34;, nameof(itemCount)); } }   Relational pattern 關聯式模式（C# 9.0） 將運算結果與常數做比較，每個狀況中，可以用關聯運算子（\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=）來描述如何比較，而常數部分需要放在關聯運算子的右方；也可以混用常數模式，比較是否與常數值相等。這裡的常數可以用數值型別、char 或 Enum。\n使用時要注意各狀況的順序排列，例如 \u0026lt; 1 後再檢查 \u0026lt; 0，則後面的 \u0026lt; 0 永遠不會執行到，編譯器會警告錯誤，無法編譯。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static string BMIResult(double bmi) { switch (bmi) { case \u0026lt; 0: throw new ArgumentException($\u0026#34;BMI異常\u0026#34;, nameof(bmi)); case \u0026lt; 18.5: return \u0026#34;體重過輕\u0026#34;; case \u0026lt; 24.0: return \u0026#34;健康體重\u0026#34;; case \u0026lt; 27.0: return \u0026#34;體重過重\u0026#34;; default: return \u0026#34;肥胖\u0026#34;; } }   可以加上邏輯模式中的 and 來檢查運算結果是否在某範圍內：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static string BMIResult2(double bmi) { switch (bmi) { case \u0026lt; 0: throw new ArgumentException($\u0026#34;BMI異常\u0026#34;, nameof(bmi)); case \u0026gt;= 0 and \u0026lt; 18.5: return \u0026#34;體重過輕\u0026#34;; case \u0026gt;= 18.5 and \u0026lt; 24.0: return \u0026#34;健康體重\u0026#34;; case \u0026gt;= 24.0 and \u0026lt; 27.0: return \u0026#34;體重過重\u0026#34;; default: return \u0026#34;肥胖\u0026#34;; } }   Logical pattern 邏輯模式（C# 9.0） 在狀況裡面，可以用 not、and、or 的組合來表達邏輯概念，在沒有括弧的情況下，邏輯判斷優先順序 not \u0026gt; and \u0026gt; or。\nnot (否定) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static string TestNull(object obj) { if (obj is not null) return \u0026#34;not null\u0026#34;; return \u0026#34;null\u0026#34;; } static string TestNull2(object obj) { switch (obj) { case not null: return \u0026#34;not null\u0026#34;; default: return \u0026#34;null\u0026#34;; } }   and (且) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  static string BMIResult2(double bmi) { switch (bmi) { case \u0026lt; 0: throw new ArgumentException($\u0026#34;BMI異常\u0026#34;, nameof(bmi)); case \u0026gt;= 0 and \u0026lt; 18.5: return \u0026#34;體重過輕\u0026#34;; case \u0026gt;= 18.5 and \u0026lt; 24.0: return \u0026#34;健康體重\u0026#34;; case \u0026gt;= 24.0 and \u0026lt; 27.0: return \u0026#34;體重過重\u0026#34;; default: return \u0026#34;肥胖\u0026#34;; } }   or (或) 1 2 3 4 5 6 7 8 9 10 11 12  static string BMIResult3(double bmi) { switch (bmi) { case \u0026lt; 0: throw new ArgumentException($\u0026#34;BMI異常\u0026#34;, nameof(bmi)); case \u0026lt; 18.5 or \u0026gt; 24.0: return \u0026#34;體重過輕或過重\u0026#34;; default: return \u0026#34;健康體重\u0026#34;; } }   Property pattern 屬性模式 (C# 8.0) 使用運算式結果的屬性或欄位值來進行比對，屬於遞迴模式（recursive pattern），可以嵌套 （nested）其他模式比對；例如在宣告模式或型別模式中，檢查型別外，亦可加上屬性模式來檢查其屬性或欄位的值是否符合；或者在屬性模式上套嵌屬性模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static double GetRectangleArea(Rectangle rectangle) { switch (rectangle) { case { Width: 0 }: case { Height: 0 }: return 0; default: return rectangle.Height * rectangle.Width; } } static double GetArea(Shape shape) { switch (shape) { case Rectangle { Width: 0 }: case Rectangle { Height: 0 }: case Circle { Radius: 0 }: return 0; case Rectangle rectangle: return rectangle.Height * rectangle.Width; case Circle circle: return Math.PI * circle.Radius * circle.Radius; default: throw new ArgumentException(); } }   Positional pattern 位置模式 (C# 8.0) Tuple 的應用。當運算式的結果是 Tuple 或其型別具有解構方法（Deconstruct method）時，可以針對每個元素進行比對。也屬於遞迴模式（recursive pattern），微軟文件中有更多的範例。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static decimal GetTotal(decimal price, int count) { switch (price, count) { case (\u0026gt;= 500, \u0026gt;= 10): return price * count * 0.8m; case (\u0026gt;= 500, \u0026gt; 0): case (\u0026gt;= 50, \u0026gt;= 10): return price * count * 0.9m; default: return price * count; } }   var pattern 隱含型別模式 (C# 7.0) 將運算式的結果指派給某個區域變數時，此變數型別可用隱含型別 var 表達，常用在取代 default 的狀況，藉以將運算的結果在 default 的狀況中再次使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static bool TestValidBMI(Person person) { switch (person.GetBMI()) { case \u0026lt; 0: case null: Console.WriteLine($\u0026#34;Invalid BMI value!\u0026#34;); return false; case var bmi: Console.WriteLine($\u0026#34;Person with BMI {bmi} accepted!\u0026#34;); return true; } }   Discard pattern 捨棄模式 (C# 8.0) 配合 switch 運算式的使用，default 的部分用底線 _ 替代，更為簡潔。\n1 2 3 4 5 6  static int GetTypeLabel(object obj) =\u0026gt; obj switch { int n =\u0026gt; 1, string s =\u0026gt; 2, _ =\u0026gt; 3, };   Parenthesized pattern 括弧模式（C# 9.0） 在任何模式的前後加上括弧，來強調或改變原本的邏輯順序。\n1 2 3 4 5 6 7 8 9 10 11 12  static string BMIResult4(double bmi) { switch (bmi) { case \u0026lt; 0: throw new ArgumentException($\u0026#34;BMI異常\u0026#34;, nameof(bmi)); case not (\u0026gt;= 18.5 and \u0026lt; 24.0): return \u0026#34;體重過輕或過重\u0026#34;; default: return \u0026#34;健康體重\u0026#34;; } }   其他： Case guards 案例防護 (C# 7.0) 利用 when 來限定其他要符合的條件，when 後面加上布林運算式。\n1 2 3 4 5 6 7 8 9 10 11 12 13  static decimal GetTotal2(decimal price, int count) { switch (price) { case \u0026gt;= 500 when count \u0026gt;= 10: return price * count * 0.8m; case \u0026gt;= 500: case \u0026gt;= 50 when count \u0026gt;= 10: return price * count * 0.9m; default: return price * count; } }   其他： switch 運算式 (C# 8.0) 在 C# 8.0 後可以使用 expression body 讓 switch 的寫法更簡潔，例如原本的：\n1 2 3 4 5 6 7 8 9 10 11 12  static int GetTypeLabel(object obj) { switch (obj) { case int n: return 1; case string s: return 2; default: return 3; } }   可以寫成：\n1 2 3 4 5 6  static int GetTypeLabel(object obj) =\u0026gt; obj switch { int n =\u0026gt; 1, string s =\u0026gt; 2, _ =\u0026gt; 3, };   運算式 (obj) 和 switch 的順序調換，減去 case 和 : 的使用，改用 =\u0026gt;；原本 case 之間則使用逗號 , 分隔，另外 default 用底線 _ 表達（捨棄模式）。\n相關連結：  [Micorsoft Docs] Patterns [Micorsoft Docs] Selection statements [Micorsoft Docs] switch expression [Micorsoft Docs] C# language versioning  ","description":"本篇整理 switch 的各種模式比對（至 C# 9.0）。","id":0,"section":"posts","tags":["switch","pattern matching"],"title":"switch 的模式比對","uri":"https://www.zoeydc.com/zh/posts/2022-04-16-switch_pattern_matching/"},{"content":"關於安裝檔的建立，在這兩篇文章「建立Installer」和「在Visual Studio將Windows Service打包成安裝檔」有找到滿詳細的說明，這裡主要是記錄製作安裝檔時其他可能用到的功能。\n 以下假設 MyExeProject 是要安裝的目標程式專案名\n VS 2017/2019 建立 Installer Project 因為 Installer Project 在 Visual Studio 2017/2019 不是內建的專案類型，需要另外安裝 Microsoft Visual Studio Installer Projects。\n Visual Studio 2017：工具 → 擴充功能和更新。\nVisual Studio 2019：延伸模組 → 管理延伸模組。\n  搜尋「Microsoft Visual Studio Installer Projects」下載安裝程式，等關閉 Visual Studio 後會進行安裝，之後要建立 Installer 的專案時找到「Setup Project」即可。\n 執行檔加入數位簽章，並打包進安裝檔 進入 MyExeProject 專案的屬性頁面，找到「簽署」，勾選「簽署 ClickOnce 資訊清單」，然後從存放區或檔案匯入簽章。\n 再到「安全性」頁面，勾選「啟用 ClickOnce 安全性設定」。\n 這樣程式編譯完後，在 bin 的 Debug 或 Release 內新建的資料夾 app.publish 中會產生已加入簽章的執行檔，但是安裝檔專案在建置時這個檔案不會自動包裝到安裝檔中，所以還需要額外進行處理。\nInstaller 的專案輸出其實是從 obj 資料夾中抓過來的，所以可以在安裝檔建置前，先將 obj 中的檔案取代成已經加入數位簽章的檔案，再進行建置。\n就用 PreBuildEvent 來處理。\n 1 2 3 4 5 6  REM 只在 Release 組態時進行 if \u0026#34;$(Configuration)\u0026#34; == \u0026#34;Release\u0026#34; ( cd \u0026#34;$(ProjectDir)\u0026#34; cd .. copy /Y \u0026#34;MyExeProject\\bin\\$(Configuration)\\app.publish\\MyExeProject.exe\u0026#34; \u0026#34;MyExeProject\\obj\\$(Configuration)\\MyExeProject.exe\u0026#34; )   建立傳入引數的捷徑 在檔案系統（File System）建立捷徑後，捷徑的屬性視窗 Arguments 欄位填入引數即可。\n  偵測所需的 .NET Framework 版本 如果軟體安裝前有其他必須安裝的 .NET 或 SQL 相關元件，可以在 Installer 專案的屬性頁「Prerequisties\u0026hellip;」進行設定，如下圖：\n 勾選「建立安裝程式以安裝必要條件元件」，即設定安裝檔建置後會一併產生 Setup.exe 檔案，要安裝時必須先點擊這個檔案，先安裝必要的元件，安裝完後會自動進入程式的安裝。\n但是即使機器原本已經有裝了勾選的元件，還是會啟動必要元件的安裝程式進行安裝（至少我測試是這樣），而且這樣一來需要釋出兩個檔案：Setup.exe 和主要安裝檔 msi 檔，所以最後沒用到這個功能。\n而 msi 檔本身可以設定所需的啟動條件，例如 .NET Framework 版本需求等，在版本未達到時會出現提示且開啟預設的下載頁面，設定方式如下：\n   當安裝時作業環境未達到啟動條件時，會出現提示：\n 這樣安裝時只需要 msi 檔即可，而且環境達到啟動條件就不會出現提示，而是直接進到安裝程序。\n除了檢查 .NET Framework 版本外，應該可以加上更複雜的啟動條件設定，如果要再深入研究，也許可以參考微軟相關文章「Add launch conditions」。\n安裝新版程式時自動取代舊版本 步驟如下：\n 設定 MyExeProject 的版本資訊：進到專案屬性→應用程式頁面→組件資訊，設定「組件版本」和「檔案版本」為新的版本號（設定前三碼，第四碼忽略），例如 3.1.2 版如下：   設定 Installer 專案的版本：專案屬性欄位 Version 設定和步驟 1 相同的版本號，如果設定後詢問是否修改 ProductCode，選「是」（若未詢問，則手動更新 ProductCode）。   確認 Installer 專案的屬性：DetectNewerInstalledVersion 和 RemovePreviousVersions 為 True。   這樣未來更新版本號，只要將版號增加，重複 1 和 2 兩個步驟的設定，安裝新版本時就可以自動覆蓋舊版本檔案，不過啟動安裝前，舊版程式還是要先關閉才行。\n安裝完成後自動啟動程式 在 MyExeProject 的 Installer Class 加上以下程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [RunInstaller(true)] public partial class ProgramInstaller : Installer { public ProgramInstaller() { InitializeComponent(); this.Committed += new InstallEventHandler(InstallerCommitted);  } private void InstallerCommitted(object sender, InstallEventArgs e) { ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = this.Context.Parameters[\u0026#34;assemblypath\u0026#34;]; startInfo.Arguments = \u0026#34;\u0026#34;;  Process.Start(startInfo); } }   以上方式啟動執行檔時，會是執行安裝時的權限（系統管理員），如果需要回復到登入時的權限來啟動執行檔，可以改為：\n1 2 3 4 5 6 7  private void InstallerCommitted(object sender, InstallEventArgs e) { ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = \u0026#34;explorer.exe\u0026#34;; startInfo.Arguments = this.Context.Parameters[\u0026#34;assemblypath\u0026#34;];  Process.Start(startInfo); }   比較困擾的是，程式無法在安裝程序最後一個畫面關閉後才啟動，而是在安裝進度條跑完後就啟動。不知道有沒有更好的方法？\n登入系統後自動啟動程式 如果是常用的程式，希望在每次登入電腦後都可以自動啟動，可以在登錄檔 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 的位置新增鍵值，名稱可任意取，內容就是放執行檔路徑（可加上引數），使用者登入後系統就會執行檔案。\n一樣是在 Committed 時處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [RunInstaller(true)] public partial class ProgramInstaller : Installer { public ProgramInstaller() { InitializeComponent(); this.Committed += new InstallEventHandler(InstallerCommitted); } private void InstallerCommitted(object sender, InstallEventArgs e) { string path = this.Context.Parameters[\u0026#34;assemblypath\u0026#34;]; string keyName = @\u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;;  RegistryKey rk = Registry.LocalMachine.CreateSubKey(keyName); rk.SetValue(\u0026#34;MyExeProject\u0026#34;, $\u0026#34;\\\u0026#34;{path}\\\u0026#34; -aa -bb\u0026#34;, RegistryValueKind.String);  rk.Close(); } }   實際寫到登錄檔畫面：\n  如果是 32 位元程式安裝到 64 位元系統，上述程式碼執行後，實際登錄檔會寫在 SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\n 依照需求，可以設定在 Local Machine 層級或是 Current User 上，如果兩個都設定登入時會啟動兩次，可能需考慮程式會不會產生衝突。\n除了 Run 外，還有 RunOnce ，只需要在重新開機後執行一次的，就可以放到 RunOnce（微軟文件）。\n建立自解壓縮檔 這將打包壓縮數個檔案成一個可自動解壓縮的執行檔，使其執行時自動解壓縮，同時啟動裡面某個 exe 檔。可以用來建立免安裝檔（可攜式軟體），或者如果有用到 Setup.exe 來預先安裝某些元件時，也可以用這個技巧將 Setup.exe 和 msi 檔合併成一個檔案來釋出。\n參考的保哥的「如何利用 7-zip 設定自動解壓縮並解壓縮後自動啟動程式」就可以產生免安裝檔，簡述方法如下：\n 到「7-Zip 官網」下載 LZMA SDK：現在 SFX 模組和其他的 SDK 都涵蓋在 LZMA SDK 中，我下載的是 19.00 版。解壓縮 bin 底下的 7zr.exe 和 7zSD.sfx，將檔案放到 MyExeProject 的 bin 底下，方便之後要直接加入 Debug 或 Release 整個資料夾內容。    新增文字檔 config.txt，內容包含訊息視窗的標題（Title）、提示內容（BeginPrompt），讓使用者確認後再進行解壓縮，還有解壓縮後要執行的程式路徑（RunProgram）等。範例如下：  ;!@Install@!UTF-8! Title=\u0026quot;Zoey的程式日常\u0026quot; BeginPrompt=\u0026quot;您要執行 Zoey的測試軟體 嗎？\u0026quot; RunProgram=\u0026quot;Debug\\MyExeProject.exe\u0026quot; ;!@InstallEnd@! 將 7zr.exe 壓縮檔案及產生可執行檔的指令寫成批次檔（例如 SFXDebug.bat）：  1 2 3 4 5 6 7  REM 將資料夾 Debug 加入壓縮檔 (檔名 Debug.7z) 7zr.exe a Debug.7z Debug\\ REM 將以下檔案從壓縮檔中移除 7zr.exe d Debug.7z Debug\\MyExeProject.pdb 7zr.exe d Debug.7z Debug\\*.xml REM 利用 7zSD.sfx、config.txt 和壓縮檔 Debug.7z 產生可執行檔（檔名 Debug.exe） copy /b 7zSD.sfx + config.txt + Debug.7z Debug.exe   在 MyExeProject 專案的「建置後事件」加上指令執行批次檔，參考如下：  1 2 3 4 5 6  if \u0026#34;$(ConfigurationName)\u0026#34; == \u0026#34;Debug\u0026#34; ( cd \u0026#34;$(ProjectDir)bin\u0026#34; SFXDebug.bat ) else ( REM 略... )   而在建立免安裝檔過程中，我遇到的狀況是，因為軟體本身不需要以系統管理員權限執行，但是使用 7-Zip 的 7zSD.sfx 檔，會需要系統管理員權限，所以需要將下載的 SFX 檔進行改造，才能在不須提高權限下就能執行。\n7zSD.sfx 檔案改造方式：\n 新增 manifest.xml，與 7zSD.sfx 放在同一目錄下，內容為：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;assembly manifestVersion=\u0026#34;1.0\u0026#34; xmlns=\u0026#34;urn:schemas-microsoft-com:asm.v1\u0026#34;\u0026gt; \u0026lt;assemblyIdentity version=\u0026#34;1.0.0.0\u0026#34; name=\u0026#34;MyApplication.app\u0026#34;/\u0026gt; \u0026lt;trustInfo xmlns=\u0026#34;urn:schemas-microsoft-com:asm.v2\u0026#34;\u0026gt; \u0026lt;security\u0026gt; \u0026lt;requestedPrivileges xmlns=\u0026#34;urn:schemas-microsoft-com:asm.v3\u0026#34;\u0026gt; \u0026lt;requestedExecutionLevel level=\u0026#34;asInvoker\u0026#34; uiAccess=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/requestedPrivileges\u0026gt; \u0026lt;/security\u0026gt; \u0026lt;/trustInfo\u0026gt; \u0026lt;compatibility xmlns=\u0026#34;urn:schemas-microsoft-com:compatibility.v1\u0026#34;\u0026gt; \u0026lt;application\u0026gt; \u0026lt;!-- Windows Vista --\u0026gt; \u0026lt;supportedOS Id=\u0026#34;{e2011457-1546-43c5-a5fe-008deee3d3f0}\u0026#34; /\u0026gt; \u0026lt;!-- Windows 7 --\u0026gt; \u0026lt;supportedOS Id=\u0026#34;{35138b9a-5d96-4fbd-8e2d-a2440225f93a}\u0026#34; /\u0026gt; \u0026lt;!-- Windows 8 --\u0026gt; \u0026lt;supportedOS Id=\u0026#34;{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}\u0026#34; /\u0026gt; \u0026lt;!-- Windows 8.1 --\u0026gt; \u0026lt;supportedOS Id=\u0026#34;{1f676c76-80e1-4239-95bb-83d0f6d0da78}\u0026#34; /\u0026gt; \u0026lt;!-- Windows 10 --\u0026gt; \u0026lt;supportedOS Id=\u0026#34;{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/compatibility\u0026gt; \u0026lt;/assembly\u0026gt;   假設是用 Visual Studio 2019 進行開發，以命令提示字元執行以下指令：  1 2  call \u0026#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\u0026#34; x86 mt.exe -manifest manifest.xml -outputresource:\u0026#34;7zSD.sfx;#1\u0026#34;   7zSD.sfx 即修改完成。\n 可執行檔自解壓縮後，檔案會暫存在 %USERPROFILE%\\AppData\\Local\\Temp 目錄下，以 7zS 開頭共 11 碼的資料夾中（例如：7zSC6918AEE）。\n 安裝後無法解除安裝程式 有嘗試過改造建置好的 msi 檔，結果安裝完後卻無法解除安裝，幸好網路上找到了一個方法可以處理這個狀況（除了用現有的強制移除安裝軟體外），也順便瞭解了 Windows 系統如何記錄「新增移除程式」（或「程式和功能」）清單。\n 以下牽涉到登錄檔的操作，請謹慎小心注意！\n  安裝程式的資訊記錄在 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ 或 WOW6432Node 的相對路徑的登錄檔中，各軟體的機碼可能以 GUID 或軟體名稱呈現，各個機碼下可找到鍵值 DisplayName 就是顯示在清單上的名稱，DisplayVersion 是軟體版本等。  例如 Microsoft SQL Server 2017 Setup 在應用程式清單畫面為（Windows 10）：\n 登錄檔資訊為：\n 在清單使用「修改」或「解除安裝」功能時，就是分別執行鍵值 ModifyPath 或 UninstallString 所存的指令。\n以 Setup Project 專案製作的安裝檔，安裝後其路徑機碼 GUID 就是屬性中的 ProductCode，ProductName 為 DisplayName，Version 為 DisplayVersion，Author 為 Contact，Manufacturer 為 Publisher 等。\n 在此可以將欲移除的軟體的機碼含子機碼整個刪除，這時在應用程式清單中就不會再出現這個軟體。\n例如將 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{GUIDXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} 刪除\n 接下來將上述的 GUID 重組，以 - 做為區隔，前三個部份字串進行反轉，後兩個部分每兩個字符順序調換，例如 {0D86D25D-AE80-43EE-B977-9858CA9FD43E} 會重組成 {D52D68D0-08EA-EE34-9B77-8985ACF94DE3}，然後去除符號部分，D52D68D008EAEE349B778985ACF94DE3。  到另外一個登錄檔路徑 HKLM\\SOFTWARE\\Classes\\Installer\\Products 找到這個重組的機碼（不須轉換到 WOW6432Node），比對 ProductName 無誤，即可刪除此機碼。\n參考 Microsoft SQL Server 2017 Setup 在此的登錄檔資訊為：\n 最後刪除此程式執行檔目錄（例如 C:\\Program Files (x86)\\MyExeProject），完成整個軟體的移除。\n當然，如果這個軟體安裝時有寫登錄檔或建立捷徑的話，就要另外刪除。\n以上為建立安裝檔時可能用到的小技巧，與你分享😎\n相關連結：  [VITOの學習筆記] 建立Installer 在Visual Studio將Windows Service打包成安裝檔 [stack overflow] Installer won\u0026rsquo;t overwrite existing app [CODE PROJECT] Launching Your Application After Install using Visual Studio 2005 [Micorsoft Docs] Run and RunOnce Registry Keys [WILL保哥] 如何利用 7-zip 設定自動解壓縮並解壓縮後自動啟動程式 7-Zip SDK [stack overflow] 7zip Self Extracting Archive (SFX) without administrator privileges [StackExchange] How to force uninstall a software that is installed by MSI package?  ","description":"本篇整理使用 Visual Studio Installer 來建立安裝檔的一些小技巧及免安裝檔或自解壓縮檔的建置。","id":1,"section":"posts","tags":["visual studio","installer","setup project","portableware","self extracting archives"],"title":"Visual Studio Installer Projects - 安裝檔二三事","uri":"https://www.zoeydc.com/zh/posts/2021-08-25-about_installer/"},{"content":"最近在用 struct 時一直有些疑慮，決定還是將這部分好好弄清楚，所以就整理了這篇筆記，記錄 .NET「通用語言運行庫」（CLR；Common Language Runtime）如何管理和配置記憶體資源，來存取程式運行中用到的實值型別（value types）或參考型別（reference types）變數資料。\n.NET 和 CLR 簡單而言，CLR 就是讓 .NET 應用程式可以運作的虛擬機器。\n不同 .NET 語言的來源程式碼，被各自的編譯器編譯後，都會編譯成 CIL（通用中間語言）程式碼，儲存在二進制檔案（.exe/.dll）中。當二進制檔案被執行時，CLR 才會將 CIL 即時編譯成適用於該系統環境的機器程式碼；同時 CLR 也管理和作業系統溝通與安全性問題等諸多事項，而記憶體管理就是其中一項。\n 因為 .NET 程式需要依靠 CLR 來運行，是受 CLR 所管控，所以也將這些稱為受控程式碼（managed code）；但如果是 C/C++ 程式，所有和系統環境的溝通都是由程式碼自己處理，故稱為非受控程式碼（unmanaged code）。\n記憶體管理 .NET 程式執行時，CLR 會保留一塊連續的記憶體空間供程式使用（不受其他程式干擾），這個記憶體空間將劃分為多個區域：High Frequency Heap、Stack、GC Heap、Large Object Heap 等，一般 Heap 指 GC Heap 和 Large Object Heap。\nHigh Frequency Heap   存放型別物件（Type object）：含各型別之靜態成員、方法表（Method table；存放靜態方法、虛擬方法、一般方法的指標）等。 程式執行期間一直佔用記憶體空間，不會釋出。   程式載入後，每一次遇到遇到新的靜態成員或方法（或者所屬類別的 instance 第一次建立前），就會配置一個區塊存放此型別物件。這在程式執行期間只會配置這麼一次，之後就一直占用同樣的記憶體位址，直到程式結束才會釋出；當靜態成員或方法多時，會占用比較多的記憶體空間。\nStack（堆疊）   存放區域變數，如果變數為實值型別，其值也存放在 Stack 中，如果變數為參考型別，其指標（Pointer；Heap 記憶體位址）存放在 Stack 中。 變數宣告後開始占用記憶體，離開變數可見範圍完成生命週期後，記憶體空間自動回收。   Stack 是以「後進先出」的陣列結構來存取資料。隨著程式執行緒方向前進，每宣告一個區域變數時，這個變數就會在 Stack 中「堆疊」，而在離開函式變數不再使用後，記憶體空間會自動釋放。所以先宣告的變數的記憶體空間會最後釋放，最後宣告的變數會最先回收（Last In, First Out；LIFO）。儲存在 Stack 的資料其生命週期是可以預測的，不須特意管理記憶體的釋放。\n但因為記憶體空間是有限的，程式沒有寫好而造成無限迴圈或無限遞迴時，Stack 空間不足會發生溢位錯誤（StackOverflowException）。\nHeap（堆積）- GC Heap \u0026amp; Large Object Heap   存放參考型別變數的值（物件本身）和封箱的（Boxed）實值型別物件等。 當參考型別的物件建立時，開始占用記憶體，直到空間不足時 GC 釋放沒有指標指向的物件。無法預測生命週期。   .NET 中這個區塊由 Garbage Collector（GC；垃圾回收；記憶體回收）來提供自動記憶體管理服務。自動記憶體管理（Automatic Memory Management）可以避免一些常見的問題，例如忘記釋放不再使用的物件而造成記憶體流失（Memory Leak，也就是 Stack 中的變數和指標已經移除了，但 Heap 中變數對應的物件沒有被釋放），或嘗試存取已經被釋放的物件而造成錯誤等。\n當第一個參考型別的實例建立（new）時，GC 會依據所需的記憶體大小在 GC Heap 根位址（base address）上開闢一個空間存放物件，接下來下一個物件的存放位置會與上一個相鄰，下一個再與上一個相鄰\u0026hellip;，依照這個原則依序存放直到沒有足夠的空間為止。\n當 GC 估計記憶體空間不足時，就會將不再使用、沒有指標指向的物件回收，釋放空間，然後將具有指標的物件重新排序壓縮（以複製刪除方式），將可用的空間挪到一起，供後續新增的物件使用。程式中也可以使用 GC.Collect() 建議 GC 進行回收（不代表 GC 會馬上處理），但通常不需要這麼做。\n除了 GC Heap 外，另有一個區塊用來存放大型物件（Large Object Heap），在這個區塊中，一樣是由 GC 管控記憶體配置，但是當大型物件回收後，其他的物件不會重新排序，以避免大型物件的搬移降低效能。\n當程式建立大型陣列或資料集合，CLR 無法為他們配置足夠的連續記憶體空間時，會產生 OutOfMemoryException 例外狀況。更多可能導致 OutOfMemoryException 的原因可以參考微軟文件。\nStack vs Heap    項目 Stack Heap     特點 靜態記憶體配置；記憶體配置方式具連續性、可預測 動態記憶體配置；依使用者需求配置記憶體，空間上不需具連續性   結構特性 記憶體陣列；後進先出（LIFO）的資料結構 記憶體區塊，依需求分割儲存各種資料物件，物件存取不存在順序關係   比喻 疊盤子，最後放上去的會最先拿起來  相片牆，照片可任意拿取或重新排列    儲存的資料 實值型別，和參考型別的指標 參考型別的值和封箱的實值型別變數等   記憶體配置速度 快 較慢   可否改變儲存長度 不能 可以   存取性質 不能跨執行緒存取 可跨執行緒存取   何時釋放空間（生命週期） 區域變數離開存取範圍後 沒有指標指向此物件後，由 GC 判斷 Heap 使用需求來規劃清除時機   例外狀況 StackOverflowException OutOfMemoryException    圖解資料型別與記憶體配置 原則：實值型別的值會與對應的變數或成員名稱存放相同記憶體位置，參考型別的值會存在 Heap 中，儲存其對應變數或成員名稱的地方會有這個值的指標。\n以下共用的 struct 和 class 程式碼：\n1 2 3 4 5 6 7 8 9 10 11  struct MyStruct { public int Param { get; set; } public MyClass InnerClass { get; set; } } class MyClass { public int Param { get; set; } public MyStruct InnerStruct { get; set; } }   1. 實值型別（簡單型別）區域變數 1 2 3 4 5 6 7 8 9  int a; a = 10; int b = a; int c = Add(a, b); public int Add(int x, int y) { return x + y; }    2. 參考型別（類別）區域變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14  MyClass myclass1 = new MyClass() { Param = 10 }; MyClass myclass2 = myclass1; BeNull(myclass1); ModifyClassParamTo50(myclass2); public void BeNull(MyClass s) { s = null; //不會影響原本的物件的指標 } public void ModifyClassParamTo50(MyClass s) { s.Param = 50; }    3. 參考型別（字串）區域變數 1 2 3 4 5 6 7 8 9 10  string s1 = \u0026#34;ABC\u0026#34;; string s2 = s1; s2 = \u0026#34;XYZ\u0026#34;; string s3 = StringConcatenate(s1, s2); public string StringConcatenate(string x, string y) { x += \u0026#34;@@\u0026#34;; return x + y; }    4. Struct 區域變數（含參考型別成員） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  MyStruct mystruct1 = new MyStruct() { Param = 10 }; MyStruct mystruct2 = new MyStruct() { Param = 10 }; Console.WriteLine(\u0026#34;4-1. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True  ModifyStructParamTo50(mystruct1); //作為引數會複製一份資料給方法使用 Console.WriteLine(\u0026#34;4-2. mystruct1.Param = \u0026#34; + mystruct1.Param); //10  MyClass myclass = new MyClass(); mystruct1.InnerClass = myclass; Console.WriteLine(\u0026#34;4-3. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //False mystruct2.InnerClass = myclass; Console.WriteLine(\u0026#34;4-4. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True  ModifyClassParamTo50(mystruct2.InnerClass); Console.WriteLine(\u0026#34;4-5. mystruct1.InnerClass.Param = \u0026#34; + mystruct1.InnerClass.Param); //50 Console.WriteLine(\u0026#34;4-6. mystruct2.Equals(mystruct1)：\u0026#34; + mystruct2.Equals(mystruct1)); //True Console.WriteLine(\u0026#34;4-7. myclass.Equals(mystruct1.InnerClass)：\u0026#34; + myclass.Equals(mystruct1.InnerClass)); //True  public void ModifyStructParamTo50(MyStruct s) { s.Param = 50; //修改複製來的資料，不影響原本 Struct 的值 } public void ModifyClassParamTo50(MyClass s) { s.Param = 50; }    5. 參考型別區域變數（含 Struct 成員） 1 2 3  MyClass myClass1 = new MyClass() { Param = 10, InnerStruct = new MyStruct() }; MyClass myClass2 = new MyClass() { Param = 10, InnerStruct = new MyStruct() }; Console.WriteLine(\u0026#34;5-1. myClass2.Equals(myClass1)：\u0026#34; + myClass2.Equals(myClass1)); //False    6. 實值型別封箱 Boxing 1 2  MyStruct myStruct = new MyStruct(); object boxed = myStruct;    7. 類別陣列 1  MyClass[] classArray = new MyClass[] { new MyClass(), new MyClass()};    8. Struct 陣列 1  MyStruct[] structArray = new MyStruct[] { new MyStruct(), new MyStruct()};    總結：Struct 使用時機 和 class 比較，其實 struct 的限制頗多，除了作為實值型別需考量其記憶體的使用外，其他還有 struct 只能實作介面，不能繼承或抽象化，所以只有有限的多型性。\n歸納其使用的時機如下：\n  小型資料結構，且具有實值語意（例如座標XY） 類別中希望限定只能唯讀的成員 作為方法引數，但不希望值本身受方法運算結果影響 應盡量避免 Boxing / Unboxing 如果無法確定，就還是用 class   相關連結：  [C#Corner] Stack Vs Heap Memory - C# [C#Corner] Working With Static In C# [CODE PROJECT] Static Keyword Demystified [stack overflow] Where are all the static members stored? [Microsoft Docs] Automatic Memory Management [Microsoft Docs] C# 型別系統  [Microsoft Docs] Structs Struct V.S Class 兩者之間差異 Why is List 15 Times Faster to Allocate than List in C# [Book] Head First C#, 4th Edition  ","description":"簡單整理 .NET「通用語言運行庫」（Common Language Runtime）如何管理和配置記憶體資源，以存取程式運行中所用的實值型別（value types）或參考型別（reference types）變數資料。","id":2,"section":"posts","tags":["CLR","stack","heap","value types","reference types","struct"],"title":"CLR、記憶體管理與資料型別","uri":"https://www.zoeydc.com/zh/posts/2021-07-10-clr_stack_heap_csharp_types/"},{"content":"有時後開發中需要測試不同環境或裝置開啟網站的差異，而為了方便偵錯，可以讓 IIS Express 啟動的網站允許外部連線進來。\n⼀、系統環境  Windows Server 2012 Visual Studio 2012  二、取得本機端 IP 以 ipconfig 取得本機端的 IP（例如 192.168.40.1）\n三、以系統管理員⾝分開啟 Visual Studio 一定要用系統管理員⾝分執⾏ Visual Studio，因為更改成非 localhost 的繫結設定後需要系統管理員權限才能執⾏ IIS Express。\n如果沒有用系統管理員執行，可能會跳出以下訊息：\n 四、設定 applicationhost.config 開始偵錯，IIS Express執⾏後，取得網站名稱，並找到組態檔 applicationhost.config。\n   （VS 2012 在「我的文件」中：「%USERPROFILE%\\My Documents\\IISExpress\\config\\applicationhost.config」；VS 2019 在「⽅案資料夾.vs\\專案名稱\\config\\applicationhost.config」。）\n 開啟檔案後，依照網站名稱找到對應的設定，修改原本的繫結設定，將 localhost 改成本機的 IP（例如 bindingInformation=\u0026quot;*:62754:localhost\u0026quot; 改為 bindingInformation=\u0026quot;*:62754:192.168.40.1\u0026quot;），然後存檔。\n1 2 3 4 5 6 7 8 9  \u0026lt;site name=\u0026#34;TestSite(1)\u0026#34; id=\u0026#34;3\u0026#34;\u0026gt; \u0026lt;application path=\u0026#34;/\u0026#34; applicationPool=\u0026#34;Clr4IntegratedAppPool\u0026#34;\u0026gt; \u0026lt;virtualDirectory path=\u0026#34;/\u0026#34; physicalPath=\u0026#34;C:\\TestSite\\TestSite\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;bindings\u0026gt; \u0026lt;binding protocol=\u0026#34;http\u0026#34; bindingInformation=\u0026#34;*:62754:192.168.40.1\u0026#34; /\u0026gt; \u0026lt;binding protocol=\u0026#34;https\u0026#34; bindingInformation=\u0026#34;*:44372:192.168.40.1\u0026#34; /\u0026gt;  \u0026lt;/bindings\u0026gt; \u0026lt;/site\u0026gt;   五、設定輸入規則 控制台→Windows防火牆→進階設定→輸入規則→新增規則→選擇連接埠→設定要開放的\nport（以上面例子來說就是 62754 和 44372）→完成設定\n 六、重新啟動網站 關閉 IIS Express，結束偵錯（但不要關閉 VS），然後再重新進入偵錯，啟動網站。\n七、手機端測試連線 手機使⽤對應的 URL，例如 http://192.168.40.1:62754，即可瀏覽。\n 個⼈偏好，在測試完成後，會將 applicationhost.config 繫結改回來 localhost，不然重開專案後，繫結可能重設，網站名稱和編號會⼀直增加 （例如 TestSite → TestSite(1) → TestSite(2) → …）\n 備註：狀況排解 以下是我設定時曾經遇到的狀況和解決方法：\n狀況⼀、The site can’t be reached.（無法連上這個網站） → 檢查輸入規則是否設定成功。\n 狀況⼆、Bad Request – Invalid Hostname → 檢查 applicationhost.config 的繫結設定\n 相關連結：  Using Custom Domains With IIS Express  ","description":"有時開發中需要測試不同環境或裝置開啟網站的差異，而為了方便偵錯，可以讓 IIS Express 啟動的網站允許外部連線進來。","id":3,"section":"posts","tags":["IIS Express","debug"],"title":"讓 IIS Express 允許外部連接（區網內手機或其他電腦等）","uri":"https://www.zoeydc.com/zh/posts/2021-06-27-enable_external_access_on_iis_express/"},{"content":"當桌⾯應⽤程式需要網路資源時，可以⽤ HttpClient 或 WebClient 等發送 HTTP 請求，但有時反過來想要開放桌⾯程式的資源供外界使⽤呢？這時就可以⽤ Self Host 的⽅式，不需要依附 IIS 就可以在程式裡掛載 Web API，為程式和外界聯繫提供⼀個管道。\n本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。\n一、系統環境  Windows 10 Visual Studio 2019 .NET Framework 4.7.2  ⼆、建立 Startup.cs，Web API 的進入點 ⾸先，安裝套件：\n Install-Package Microsoft.AspNet.WebApi.OwinSelfHost -Version 5.2.7\n （OWIN 為 .NET Framework 4.5 以上使⽤， 4.0 ⽤ Microsoft.AspNet.WebApi.SelfHost 裝載 Web API）\n接著新增類別（或 OWIN 啟動類別）Startup.cs，設定路由規則，讓 Web API 以此規則在 OWIN 上運⾏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  using System.Web.Http; //using System.Web.Http.Cors; using Microsoft.Owin; using Owin; [assembly: OwinStartup(typeof(SelfHostConsole.Startup))] namespace SelfHostConsole { public class Startup { public void Configuration(IAppBuilder app) { // 如需如何設定應用程式的詳細資訊，請瀏覽 https://go.microsoft.com/fwlink/?LinkID=316888  // Configure Web API for self-host.  HttpConfiguration config = new HttpConfiguration(); config.Routes.MapHttpRoute( name: \u0026#34;DefaultApi\u0026#34;, routeTemplate: \u0026#34;api/{controller}/{id}\u0026#34;, defaults: new { id = RouteParameter.Optional } );  //Enable CORS  //config.EnableCors(new EnableCorsAttribute(\u0026#34;*\u0026#34;, headers: \u0026#34;*\u0026#34;, methods: \u0026#34;*\u0026#34;));  app.UseWebApi(config);  } } }   如果網站需要跨域資源共享（CORS），則需安裝 CORS 套件，並啟用上述第 2 和 22 ⾏：\n Install-Package Microsoft.AspNet.WebApi.Cors -Version 5.2.7\n 接下來在 Program.cs 裡設定執⾏程式時啟動 Web API host：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using Microsoft.Owin.Hosting; using System; namespace SelfHostConsole { class Program { static void Main(string[] args) { string baseAddress = \u0026#34;http://localhost:55000/\u0026#34;; Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(url: baseAddress)) { Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); }  } } }   此時若以 Postman 測試 Get 訪問 http://localhost:55000/ 會收到 404 Not Found，⽽不是出現 Error: connect ECONNREFUSED 127.0.0.1:55000 這樣的訊息，表⽰這時候 Web API 的基本架構已經完成了。\n三、加入 Controller 依照習慣取代配置（Convention over Configuration）的原則，Controller 以 Controller 結尾就可以被找到，這邊簡單加個 TestController。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System.Collections.Generic; using System.Web.Http; namespace SelfHostConsole { public class TestController : ApiController { private static List\u0026lt;MyModel\u0026gt; list = new List\u0026lt;MyModel\u0026gt;() { new MyModel(){Name=\u0026#34;name1\u0026#34;, Value=\u0026#34;value1\u0026#34;}, new MyModel(){Name=\u0026#34;name2\u0026#34;, Value=\u0026#34;value2\u0026#34;}, }; // GET api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Get() { return list; } // GET api/test/1  public MyModel Get(int id) { if (id \u0026lt; 0 || id \u0026gt;= list.Count) return null; return list[id]; } // POST api/test  public IEnumerable\u0026lt;MyModel\u0026gt; Post([FromBody] MyModel newData) { list.Add(newData); return list; } } public class MyModel { public string Name { get; set; } public string Value { get; set; } } }   這樣 Web API 就可以運作了。\n⽤ Postman 測試⼀下，運作正常。\n 如果 Postman 收到以下的訊息，確認⼀下是否有將 Controller 設為 public class。\n1 2 3 4  { \u0026#34;Message\u0026#34;: \u0026#34;No HTTP resource was found that matches the request URI \u0026#39;http://localhost:55000/api/test\u0026#39;.\u0026#34;, \u0026#34;MessageDetail\u0026#34;: \u0026#34;No type was found that matches the controller named \u0026#39;test\u0026#39;.\u0026#34; }   四、安裝 SSL 憑證，啟⽤ HTTPS 若要啟⽤ HTTPS，程式碼網址部分直接修改成 https 即可。除此之外環境要安裝 SSL 憑證。\n1. 建立 SSL 憑證 這邊⽤ OpenSSL 建立憑證，取得 crt 和 pfx 檔後，匯入⾃簽憑證到「受信任的根憑證授權單位」和「伺服器憑證」。\n以系統管理員⾝分執⾏命令提⽰字元，其中 CertPassword 取代為在建立 pfx 檔時所輸入的密碼。：\n1  certutil -f -p CertPassword -importpfx \u0026#34;server.pfx\u0026#34;   2. 取得憑證指紋（Thumbprint） 在「開始」功能表搜尋 mmc 或 certlm.msc ，進到憑證管理介⾯，在「個⼈」或「受信任的根憑證授權單位」中找到匯入的憑證名稱，快點兩下進到「詳細資料」畫⾯，將憑證指紋記錄下來。（也可⽤ openssl 取得憑證指紋)\n 3. 將 SSL 憑證和 Port 綁定 以系統管理員⾝分執⾏命令提⽰字元，其中 certhash 為上⼀步驟得到的憑證指紋，appid 則填入任意⼀組 GUID。：\n1  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a}   4. 進⾏測試 Postman 測試時可能會出現 Error: self signed certificate，是因為憑證檢核時⾃簽憑證無法過關，需要在設定裡將「SSL certificate verification」關閉（建議測試完後恢復進⾏檢核）。正常來說可以得到和先前⼀樣的結果，除了網址 http 現在換成 https。\n五、繫結多個 IP 或域名 在 Program.cs 啟動 Web API 是使用 WebApp.Start(url: baseAddress) 來設定網址，觀察它的 Metadata，Start 方法除了傳入 url 網址外，還有另一個傳入 StartOptions 的多載，裡面有個 Urls 的 Property，說明為「A list of url prefixes to listen on. Overrides port.」，所以就是從這邊下手了。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Program { static void Main(string[] args) { StartOptions options = new StartOptions(); options.Urls.Add(\u0026#34;https://localhost:55000/\u0026#34;); options.Urls.Add(\u0026#34;http://localhost:55001/\u0026#34;);  Console.WriteLine(\u0026#34;Start OWIN host ...\u0026#34;); using (WebApp.Start\u0026lt;Startup\u0026gt;(options: options)) \t{ Console.WriteLine(\u0026#34;Wait for a request ...\u0026#34;); Console.ReadLine(); } } }   這樣就完成了多個 IP 的繫結。\n補充 1. SSL 憑證安裝刪除查詢 參考「⽤ certutil 新增刪除查詢 SSL 憑證」。\n2. SSL 繫結 Port 及刪除、查詢繫結 1 2 3 4  netsh http add sslcert ipport=0.0.0.0:55000 certhash=e96255f1941688dcf4be790a2fe61079fc6a87ab appid={bd59f744-97e7-4b9b-b100-9ab561e3bd5a} netsh http delete sslcert ipport=0.0.0.0:55000 netsh http show sslcert netsh http show sslcert ipport=0.0.0.0:55000   3. 在 Windows Service 中啟動 Web API 覆寫 OnStart 與 OnStop 方法時分別建立和釋放 Web API 資源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using Microsoft.Owin.Hosting; using System; using System.ServiceProcess; namespace SelfHost { public partial class SelfHostService : ServiceBase { private IDisposable _server = null;  public SelfHostService() { InitializeComponent(); } protected override void OnStart(string[] args) { _server = WebApp.Start\u0026lt;Startup\u0026gt;(\u0026#34;https://localhost:55000/\u0026#34;);  } protected override void OnStop() { if (_server != null) { _server.Dispose(); }  base.OnStop(); } } }   相關連結：  [Microsoft Docs] ⾃我裝載 ASP.NET Web API 1 （C#） [Microsoft Docs] 使⽤ OWIN ⾃我裝載 ASP.NET Web API [Microsoft Docs] 如何：使⽤ MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] 作法：使⽤ SSL 憑證設定連接埠 [WILL保哥] 如何使⽤ OpenSSL 建立開發測試⽤途的⾃簽憑證 (Self-Signed Certificate) [⿊暗執⾏緒] PostMan 無法連線 IIS Express 網站 OWIN WebAPI Service example ","description":"本篇是記錄在 Console 程式中如何使⽤ Microsoft.AspNet.WebApi.OwinSelfHost 建置 Web API，包含使⽤ HTTPS 網址、繫結多個 IP 或域名、啟⽤ CORS 等，最後補充了管理 SSL 憑證相關指令與 Windows Service 中啟動 Web API 的程式碼。","id":4,"section":"posts","tags":["OWIN","Self Host","ASP.NET","Web API","SSL","IIS"],"title":"免 IIS，⽤ OWIN 架設輕量級 ASP.NET Web API","uri":"https://www.zoeydc.com/zh/posts/2021-06-13-owin-selfhost-webapi-console/"},{"content":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。\n前置作業：查詢憑證指紋（Fingerprint、Thumbprint） 本篇憑證是⽤ OpenSSL 所產⽣的 crt 和 pfx 檔，另外刪除或查詢憑證資訊時需⽤到憑證指紋，可 (1) 直接⽤ OpenSSL 取得，或 (2) 匯入憑證後進到 MMC 介⾯查詢 。\n(1) OpenSSL 將取得類似「SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB」的⼀串文字，使⽤時取「Fingerprint=」之後的文字並將冒號去除。\n以命令提示字元執行查詢：\n1 2 3 4 5 6 7 8 9  REM CertificateFile 為憑證檔名稱 REM 查詢憑證指紋 \u0026gt; openssl x509 -in CertificateFile.crt -fingerprint -noout SHA1 Fingerprint=E9:62:55:F1:94:16:88:DC:F4:BE:79:0A:2F:E6:10:79:FC:6A:87:AB REM 查詢序號 \u0026gt; openssl x509 -in CertificateFile.crt -serial -noout serial=6D53BD345F83AF5C3CFC1CE36C2540273C74B607   (2) MMC 介面  受信任的根憑證授權單位（root） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  REM 匯入 certutil -addstore -f \u0026#34;ROOT\u0026#34; CertificateFile.crt REM 上述匯入憑證後，如要再匯入密鑰（⼀般不需要） REM CertPassword 為產⽣ pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx root \u0026#34;CertificateFile.pfx\u0026#34; REM 依憑證指紋進行刪除 certutil -delstore root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有受信任的根憑證 certutil -store root REM 針對憑證指紋進⾏查詢 certutil -store root \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   個⼈存放區（my） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  REM 匯入憑證（無密鑰） certutil -addstore -f my CertificateFile.crt REM 匯入憑證及密鑰到個人存放區，「同時」也會新增到受信任的根憑證授權單位 root REM CertPassword 為產生 pfx 時輸入的密碼 certutil -f -p CertPassword -importpfx my \u0026#34;CertificateFile.pfx\u0026#34; (certutil -f -p CertPassword -importpfx \u0026#34;CertificateFile.pfx\u0026#34;) REM 依憑證指紋進行刪除 REM 只刪除在個人存放區 \u0026#34;my\u0026#34; 的憑證，刪除在 \u0026#34;root\u0026#34; 的憑證需要另外執行 certutil -delstore my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34; REM 查詢所有個人憑證 certutil -store my REM 針對憑證指紋進行查詢 certutil -store my \u0026#34;e96255f1941688dcf4be790a2fe61079fc6a87ab\u0026#34;   備註1：若匯入 pfx 檔到個人存放區，則在 IIS 的伺服器憑證中也可以查詢到。\n備註2：若是從 IIS 伺服器憑證匯入憑證到個人存放區，那就只會在個人存放區有，不會同時新增到 root。\n備註3：若是管理「目前的使用者」（Current User）的憑證，在 certutil 後加上 -user 即可，例如：certutil -user -addstore -f my CertificateFile.crt。「目前的使用者」的憑證會繼承「本機電腦」所有的憑證，除了在「本機電腦」的「個人存放區」的憑證（參考連結3）。\n相關連結：  [Microsoft Docs] 如何：使用 MMC 嵌入式管理單元來查看憑證 [Microsoft Docs] certutil [Microsoft Docs] Local Machine and Current User Certificate Stores ","description":"記錄⽤ certutil 新增、刪除、查詢在「本機電腦」的「個⼈」或「受信任的根憑證授權單位」存放區的 SSL 憑證的指令。","id":5,"section":"posts","tags":["certutil","SSL"],"title":"⽤ certutil 新增刪除查詢 SSL 憑證","uri":"https://www.zoeydc.com/zh/posts/2021-06-04-certutil-store-ssl/"},{"content":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定（例如資料庫連線字串、系統資源對應路徑等），這些繁瑣的設定若是每次都⼿動修改實在容易出錯，⽽ Visual Studio 本⾝就有 Web.config 組態檔轉換功能，好好利⽤可以⼤⼤節約時間並降低錯誤機率，更能專注在開發本⾝。\n專案建立好時預設有兩個組態 Debug 和 Release，⼀般我會再建立⼀個 Test 組態在測試環境使⽤，所以本篇記錄 1. 如何新增組態和與之對應的 Web.config 設定檔，和 2. 設定 Web.config 轉換內容。\n⼀、前置作業  以 ASP.NET MVC 的預設範本建立專案（Visual Studio 2019） 檢視預設組態設定：預設的 Debug 和 Release 組態各有⼀個對應的 config 檔（Web.{組態名稱}.config）   ⼆、新增組態設定與設定檔 從「組態管理員」中新增「Test」組態後，在⽅案總管中會發現 Web.Test.config 檔案並沒有⾃動產⽣，需要⼿動「新增設定轉換」（Add Transform），檔案就會出現了。\n  三、設定不同組態發⾏時對應的 Web.config 接下來要編輯這些檔案裡⾯的內容了！了解語法之前來快速看⼀下⼀個簡單的轉換範例和呈現的效果。\n範例與效果 就以發佈 Release 組態來說，假設原本的 Web.config 有個參數 Env：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Dev\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 對照在 Web.Release.config 的 Env 參數設定，除了將 value 設為 Release 外，另外加了 xdt:Transform 和 xdt:Locator 屬性（屬性詳細說明⾒下方語法詳述），如下：\n\u0026lt;appSettings\u0026gt; \u0026lt;add key=\u0026#34;Env\u0026#34; value=\u0026#34;Release\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(key)\u0026#34;/\u0026gt; \u0026lt;/appSettings\u0026gt; 實際發佈時， Env 的設定就會轉換為 Release了。\n或者可以⽤內建的預覽⼯具發佈前預先檢視結果與差異處：\n  ↑ 左邊是原始的設定檔，右邊則是轉換後的結果，差異處也都⾃動標記了。\n語法詳述（Web.config Transformation Syntax） 回顧⼀下 Web.Release.config 的原始內容，或者新建的 Web.Test.config 也有相同的內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!-- 如需使用 web.config 轉換的詳細資訊，請前往 https://go.microsoft.com/fwlink/?LinkId=125889 --\u0026gt; \u0026lt;configuration xmlns:xdt=\u0026#34;http://schemas.microsoft.com/XML-Document-Transform\u0026#34;\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;SetAttributes\u0026#34; 轉換只會在 \u0026#34;Match\u0026#34; 定位程式找到 值為 \u0026#34;MyDB\u0026#34; 的屬性 \u0026#34;name\u0026#34; 時，才將 \u0026#34;connectionString\u0026#34; 的值變 更為使用 \u0026#34;ReleaseSQLServer\u0026#34;。 \u0026lt;connectionStrings\u0026gt; \u0026lt;add name=\u0026#34;MyDB\u0026#34; connectionString=\u0026#34;Data Source=ReleaseSQLServer;Initial Catalog=MyReleaseDB;Integrated Security=True\u0026#34; xdt:Transform=\u0026#34;SetAttributes\u0026#34; xdt:Locator=\u0026#34;Match(name)\u0026#34;/\u0026gt; \u0026lt;/connectionStrings\u0026gt; --\u0026gt; \u0026lt;system.web\u0026gt; \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;  \u0026lt;!-- 在下面的範例中，\u0026#34;Replace\u0026#34; 轉換將會取代 web.config 檔案 的整個 \u0026lt;customErrors\u0026gt; 區段。 請注意，因為在 \u0026lt;system.web\u0026gt; 節點之下 只有一個 customErrors 區段，所以不需要使用 \u0026#34;xdt:Locator\u0026#34; 屬性。 \u0026lt;customErrors defaultRedirect=\u0026#34;GenericError.htm\u0026#34; mode=\u0026#34;RemoteOnly\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34;\u0026gt; \u0026lt;error statusCode=\u0026#34;500\u0026#34; redirect=\u0026#34;InternalError.htm\u0026#34;/\u0026gt; \u0026lt;/customErrors\u0026gt; --\u0026gt; \u0026lt;/system.web\u0026gt; \u0026lt;/configuration\u0026gt;   和⼀般 Web.config 不同的是，它引⽤了 XML-Document-Transform 命名空間（第 3 ⾏），對應到 xdt 前置詞的使⽤（xdt:Locator 和 xdt:Transform），⽤來處理元素和屬性的轉換；xdt 前置詞在轉換後的文件中不會出現。\n【Locator】 ⽤來定位要轉換的元素位置，為非必要屬性，若未設定時則找出所有同層級元素，再依 Transform 屬性決定轉換模式。Locator 有三種設定⽅式。\nxdt:Locator=\u0026#34;Condition(XPath 運算式)\u0026#34; 範例：xdt:Locator=\u0026#34;Condition(@name=\u0026#39;oldname\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;)\u0026#34; 說明：找到符合 XPath 運算式條件的元素。例如屬性 name 為 oldname 或 providerName 為 oldprovider 的所有元素。\nxdt:Locator=\u0026#34;Match(屬性1,屬性2,屬性3,…)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;Match(name, providerName)\u0026#34; 說明：找到與所列屬性的值「皆」相同的元素。例如屬性 name 為 AWLT 且 providerName 為 newprovider 的所有元素。\nxdt:Locator=\u0026#34;XPath(XPath 運算式)\u0026#34; 範例：\u0026lt;add name=\u0026#34;AWLT2\u0026#34; connectionString=\u0026#34;newstring\u0026#34; providerName=\u0026#34;newprovider\u0026#34; xdt:Transform=\u0026#34;Replace\u0026#34; xdt:Locator=\u0026#34;XPath(/configuration/connectionStrings/add[@name=\u0026#39;AWLT\u0026#39; or @providerName=\u0026#39;oldprovider\u0026#39;])\u0026#34;/\u0026gt; 說明：完全使⽤ XPath 運算式（絕對路徑）來尋找元素，不以元素現在的位置為參考。例如即使將上述標籤放到 \u0026lt;appSettings\u0026gt; 元素下或直接放在 \u0026lt;configuration\u0026gt; 底下，其依然會找到 connectionStrings 中，符合 name 為 AWLT 或 providerName 為 oldprovider 的所有元素。\n【Transform】 說明元素屬性該如何轉換，有八種⽅式。\nxdt:Transform=\u0026#34;Replace\u0026#34; 說明：以轉換檔（Web.{組態名稱}.config）中的元素取代 Locator 屬性在 Web.config 中會找到的元素。如果找到多個元素，只會取代第⼀個。\nxdt:Transform=\u0026#34;Insert\u0026#34; 說明：將轉換檔的元素加入 Web.config 中 Locator 所定義的同層級的元素區域中的最後⾯。\nxdt:Transform=\u0026#34;InsertBefore(XPath 運算式)\u0026#34; 說明：將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素前⾯（不是 Locator 所指的元素，在此處 Locator 沒有作⽤）。\n1 2 3  \u0026lt;authorization\u0026gt; \u0026lt;allow roles=\u0026#34;Admins\u0026#34; xdt:Transform= \u0026#34;InsertBefore(/configuration/system.web/authorization/deny[@users=\u0026#39;*\u0026#39;])\u0026#34; /\u0026gt; \u0026lt;/authorization\u0026gt;   上⾯範例設定轉換時在「拒絕所有使⽤者」的項⽬前，插入「允許系統管理者」的授權。\nxdt:Transform=\u0026#34;InsertAfter(XPath 運算式)\u0026#34; 說明：和 InsertBefort 相反，是將轉換檔的元素插入 XPath 運算式（絕對路徑）所指的元素後⾯。\nxdt:Transform=\u0026#34;Remove\u0026#34; 說明：移除 Locator 找到的第⼀個元素。\nxdt:Transform=\u0026#34;RemoveAll\u0026#34; 說明：移除 Locator 找到的所有元素。\nxdt:Transform=\u0026#34;RemoveAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，移除所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆移除。\n1  \u0026lt;compilation xdt:Transform=\u0026#34;RemoveAttributes(debug)\u0026#34; /\u0026gt;   Web.Release.config 預設就會移除 compilation 的 debug 屬性，以提⾼發⾏時程式運⾏的效能。（原始內容第 16 ⾏）\nTransform=\u0026#34;SetAttributes(屬性1,屬性2,屬性3,…)\u0026#34; 說明：Locator 找到元素後，依照轉換檔的屬性設定所指定的⼀到多個屬性。如果未選擇任何屬性，則所有屬性皆依轉換檔進⾏設定。\n參考網址：  [Microsoft Docs] 使用 Visual Studio 的 ASP.NET Web 部署： Web.config 檔轉換 [Microsoft Docs] Web.config Transformation Syntax for Web Application Project Deployment ","description":"軟體從開發到⽣產的各個階段，很常遇到不同環境需要不同的組態設定，若能善用 Visual Studio 本⾝組態檔的轉換功能，可以⼤⼤節約時間並降低錯誤機率，更能專注在開發上。本篇記錄 (1) 如何新增組態和 Web.config 設定檔，和 (2) 設定 Web.config 轉換內容。","id":6,"section":"posts","tags":["visual studio","config transforms"],"title":"Visual Studio 發佈專案時⾃動轉換組態對應的 Web.config","uri":"https://www.zoeydc.com/zh/posts/2021-05-29-visual-studio-webconfig/"},{"content":"一直有建部落格的想法，也試過一些部落格平台和 WordPress，覺得平台上開站雖然方便，只要註冊帳號就好，但是版型調整方式有限，無法將網站改成符合自己心意的模樣，相較而言，WordPress 自由度很高，不過架構也相對複雜，還需要管理外掛和資料庫，有點麻煩，不太符合單純寫文章的想法，經過一番搜尋後，決定用靜態網站來架設我的部落格！\n雖然 GitHub Pages 推薦使用 Jekyll 生成靜態網頁，但在 Windows 環境下 Jekyll 似乎比較不友善，而 Hugo 入門相對容易、官方文件有完整的教學，還有編譯速度快等優點，眾多因素考慮下，我選擇了 Hugo。\n不過還是花了一些時間才把網站搞定，所以決定要記錄一下整個架站過程，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域，以供參考。\n 以下 {username} 為 GitHub 帳號名，{主題名稱} 為所選的佈景主題名稱，例如我的是 zzo。\n 本機端開發環境的建置 本機環境  作業系統：Windows 10\n Hugo 可以安裝在 Windows、Linux、macOS 等作業系統，Linux 或 macOS 的安裝方式請參考官方文件。\n以下建置過程預設環境已安裝 Git，也註冊 GitHub 帳號並建立名稱為 {username}.github.io 的 repo 了。\n安裝套件管理器 CHOCOLATEY 以系統管理員身分執行 PowerShell，執行以下指令：\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))   若安裝無誤，執行 choco 可得版本資訊，例如：\n1 2 3  \u0026gt; choco Chocolatey v0.10.15 Please run \u0026#39;choco -?\u0026#39; or \u0026#39;choco \u0026lt;command\u0026gt; -?\u0026#39; for help menu.   安裝 Hugo、建立新網站 PowerShell 繼續執行：\n1  choco install hugo -confirm   如果選擇的主題需要擴充套件 Sass/SCSS 版本，執行：\n1  choco install hugo-extended -confirm   若不確定是否需要擴充套件的話，可以先跳過，之後執行 hugo server 出現以下類似錯誤時再安裝 hugo-extended：\n ERROR 2021/05/08 16:44:51 TOCSS: failed to transform \u0026ldquo;main_parsed.scss\u0026rdquo; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS.\n 安裝完 Hugo 後，就可以建立新網站了。\n1 2  cd myfolder ## Hugo 會在此資料夾底下新建一個資料夾 hugo new site mywebsite ## 建立網站 \u0026amp; 資料夾 mywebsite   這個資料夾底下會建立 archetypes、content、static、themes 等資料夾，但 themes 裡面沒有預設的佈景主題，需要自己安裝。\n可以到所選的主題的 GitHub repo 下載檔案解壓縮到 themes/{主題名稱}/ 或是用 git submodule 安裝（以下以 zzo 主題為例）。\n1 2 3  cd mywebsite ## 進入網站資料夾 git init git submodule add https://github.com/zzossig/hugo-theme-zzo themes/zzo   安裝完成後，官方文件使用指令新增組態檔 config.toml：\n1  echo theme = \\\u0026#34;zzo\\\u0026#34; \u0026gt;\u0026gt; config.toml   但建議直接複製範例網站，到 themes/{主題名稱}/exampleSite/ 目錄下複製整個資料夾內容貼到 mywebsite 根目錄，再來修改組態檔，尤其有些佈景主題的組態檔結構複雜，只新增 config.toml 可能會缺少某些參數而編譯失敗。\n如果要自訂 layouts 或 i18n 的內容，也從 themes/{主題名稱}/ 下複製資料夾到根目錄後進行修改。\n先來設定 config.toml 的 baseURL 和網站語言等：\n1 2 3 4 5 6 7  # 如果使用 GitHub Pages 預設域名 baseURL = \u0026#34;https://{username}.github.io/\u0026#34; # 自訂域名範例 baseURL = \u0026#34;https://www.customdomainname.com/\u0026#34; languageCode = \u0026#34;zh-tw\u0026#34; title = \u0026#34;My Site Name\u0026#34; #自訂任意名稱   本機端啟動網站：\n以 hugo servre 方式啟動網站，Hugo 會隨時偵測檔案的異動來更新網頁，到預設網址 http://localhost:1313/ 就可以看到最新的內容，關閉網站用 CTRL+C 。\n1  hugo server   上傳到 Github Pages 發布網站 官方文件使用 GitHub Action 來佈署網站（方法一），但如果不希望將網站的原始碼放到網路上，可以選擇只提交最後編譯好的靜態網頁（方法二）。\n方法一：建立 gh-pages 分支 先確定使用的 Hugo 版本，以及是否安裝擴充套件。\n1 2  \u0026gt; hugo version hugo v0.83.1-5AFE0A57+extended windows/amd64 BuildDate=2021-05-02T14:38:05Z VendorInfo=gohugoio   將整個資料夾 Push 到 Github repo （{username}.github.io）：\n1 2 3 4 5 6  ## 現在路徑為 myfolder/mywebsite/ git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git remote add origin https://github.com/{username}/{username}.github.io.git git push -u origin main   再到 GitHub 新增 gh-pages.yml 檔案。\n  在上圖步驟 2 時，將 gh-pages.yml 內容用以下內容取代，其中 hugo-version 和 extended 再依需求進行設定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  name:github pageson:push:branches:- main # Set a branch to deployjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;# \u0026#39;0.83.1\u0026#39;# extended: true # 有用擴充套件則將 # 移除- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public  Commit 完成後，檢查 workflow 是否順利。（之後每次 main 分支有 commit 就會有新的 workflow 自動產生，重新編譯發布網站）\n  全部都 ✔ 表示順利完成編譯囉。\n接下來設定 GitHub Pages 要讀取 gh-pages 分支的檔案，設定完就可以到 https://{username}.github.io 瀏覽網站成果。\n 方法二：上傳 Public 資料夾 先以 hugo 產生靜態 html 檔案，成功的話會在 mywebsite/public/ 裡面看到檔案，再將 public 資料夾 push 到 GitHub。\n1 2 3 4 5 6 7 8 9  ## 現在路徑為 myfolder/mywebsite/ git submodule add https://github.com/{username}/{username}.github.io.git public hugo # 產生靜態 html 檔案 cd public git status # 檢查 public 資料夾，應只看到 public 中新增的檔案 git branch -M main git add . git commit -m \u0026#34;init mywebsite\u0026#34; git push -u origin main   參考上圖到 GitHub Pages 設定要讀取的分支為 main，就可以訪問 https://{username}.github.io。\n自訂網域 GitHub 官方建議先在 GitHub 中設定 CNAME，再到 DNS 供應商設定 DNS 紀錄。\n新增檔案 CNAME 在 GitHub 網站介面中可以設定網域名，其機制是在 Pages 的目標分支根目錄下加上 CNAME，但是這樣每次有檔案更新 CNAME 就會被覆蓋掉，要再重新設定，所以 Hugo 網站是要新增 CNAME 在 static 資料夾中，這樣編譯後，檔案會自動放在網站根目錄下，GitHub 就能以此偵測自訂域名。\nCNAME 檔案（無副檔名）內容就只放自訂的網域名（例如 www.customdomainname.com）。\n設定 DNS 到 DNS 供應商設定 DNS 紀錄，增加 4 筆 A Record 和 1 筆 CNAME Record（以 www 為例）。\n   Type Host Value     A Record @ 185.199.108.153   A Record @ 185.199.109.153   A Record @ 185.199.110.153   A Record @ 185.199.111.153   CNAME Record www {username}.github.io    更改 repo 名稱（非必要） 最後可以將 repo 名稱改為現在的網域，然後將 Pages 的 Enforce HTTPS 取消再重新勾選，讓 SSL 憑證重新產生。\n結論 基本上一步一步執行就可以完成 Hugo 網站建置，如果一開始就打算自訂網域也可以先新增 CNAME 檔案以及用自訂網域作 repo 名稱來簡化步驟！\n參考網址：  Hugo Docs GitHub Docs 自訂網域  其他：  編寫 Markdown 文件 ","description":"使用 Hugo 在 GitHub Pages 架設靜態網站，包含 (1) 本機端開發環境的建置、(2) 上傳到 Github Pages 發布網站、(3) 自訂網域。","id":7,"section":"posts","tags":["Hugo","Static Site Generator","Git","GitHub Pages"],"title":"網站開張！在 GitHub Pages 架設 Hugo 靜態網站","uri":"https://www.zoeydc.com/zh/posts/2021-05-23-hugo-website_github-pages_custom-domain/"}]